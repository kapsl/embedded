   1               		.file	"floorDetection.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	floorDetection
  13               	floorDetection:
  14               	.LFB1:
  15               		.file 1 "floorDetection.c"
   1:floorDetection.c **** #include "roomba.h"
   2:floorDetection.c **** #include "tools.h"
   3:floorDetection.c **** #include "usart.h"
   4:floorDetection.c **** #include <stdio.h>
   5:floorDetection.c **** #include <stdlib.h>
   6:floorDetection.c **** #include "floorDetection.h"
   7:floorDetection.c **** 
   8:floorDetection.c **** /**
   9:floorDetection.c ****  * Possible return values: 
  10:floorDetection.c ****  * 	power up detected
  11:floorDetection.c ****  * 	left border detected with angle
  12:floorDetection.c ****  * 	right border detected with angle
  13:floorDetection.c ****  */
  14:floorDetection.c **** void floorDetection(detectedType *type, uint16_t *sensorData) {
  16               		.loc 1 14 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 4
  21               		.cfi_offset 28, -3
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 5
  25               		.cfi_offset 29, -4
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2C97      		sbiw r28,12
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 17
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 12 */
  40               	/* stack size = 14 */
  41               	.L__stack_usage = 14
  42 0014 9A87      		std Y+10,r25
  43 0016 8987      		std Y+9,r24
  44 0018 7C87      		std Y+12,r23
  45 001a 6B87      		std Y+11,r22
  15:floorDetection.c **** 	int16_t cliff_front_left = sensorData[0];
  46               		.loc 1 15 0
  47 001c 8B85      		ldd r24,Y+11
  48 001e 9C85      		ldd r25,Y+12
  49 0020 FC01      		movw r30,r24
  50 0022 8081      		ld r24,Z
  51 0024 9181      		ldd r25,Z+1
  52 0026 9A83      		std Y+2,r25
  53 0028 8983      		std Y+1,r24
  16:floorDetection.c **** 	int16_t cliff_front_right = sensorData[1];
  54               		.loc 1 16 0
  55 002a 8B85      		ldd r24,Y+11
  56 002c 9C85      		ldd r25,Y+12
  57 002e 0296      		adiw r24,2
  58 0030 FC01      		movw r30,r24
  59 0032 8081      		ld r24,Z
  60 0034 9181      		ldd r25,Z+1
  61 0036 9C83      		std Y+4,r25
  62 0038 8B83      		std Y+3,r24
  17:floorDetection.c **** 	
  18:floorDetection.c **** 	// Power up
  19:floorDetection.c **** 	if (cliff_front_left + cliff_front_right > POWER_UP_CLIFF_THRESHOLD) {
  63               		.loc 1 19 0
  64 003a 2981      		ldd r18,Y+1
  65 003c 3A81      		ldd r19,Y+2
  66 003e 8B81      		ldd r24,Y+3
  67 0040 9C81      		ldd r25,Y+4
  68 0042 820F      		add r24,r18
  69 0044 931F      		adc r25,r19
  70 0046 853C      		cpi r24,-59
  71 0048 F9E0      		ldi r31,9
  72 004a 9F07      		cpc r25,r31
  73 004c 04F0      		brlt .L2
  20:floorDetection.c **** 		*type = POWER_UP;
  74               		.loc 1 20 0
  75 004e 8985      		ldd r24,Y+9
  76 0050 9A85      		ldd r25,Y+10
  77 0052 FC01      		movw r30,r24
  78 0054 1082      		st Z,__zero_reg__
  21:floorDetection.c **** 		
  22:floorDetection.c **** 		return;
  79               		.loc 1 22 0
  80 0056 00C0      		rjmp .L1
  81               	.L2:
  23:floorDetection.c **** 	}
  24:floorDetection.c **** 	
  25:floorDetection.c **** 	int16_t cliff_left = sensorData[2];
  82               		.loc 1 25 0
  83 0058 8B85      		ldd r24,Y+11
  84 005a 9C85      		ldd r25,Y+12
  85 005c 0496      		adiw r24,4
  86 005e FC01      		movw r30,r24
  87 0060 8081      		ld r24,Z
  88 0062 9181      		ldd r25,Z+1
  89 0064 9E83      		std Y+6,r25
  90 0066 8D83      		std Y+5,r24
  26:floorDetection.c **** 	int16_t cliff_right = sensorData[3];
  91               		.loc 1 26 0
  92 0068 8B85      		ldd r24,Y+11
  93 006a 9C85      		ldd r25,Y+12
  94 006c 0696      		adiw r24,6
  95 006e FC01      		movw r30,r24
  96 0070 8081      		ld r24,Z
  97 0072 9181      		ldd r25,Z+1
  98 0074 9887      		std Y+8,r25
  99 0076 8F83      		std Y+7,r24
  27:floorDetection.c **** 	
  28:floorDetection.c **** 	// Left border
  29:floorDetection.c **** 	if (cliff_left > BORDER_CLIFF_THRESHOLD) {
 100               		.loc 1 29 0
 101 0078 8D81      		ldd r24,Y+5
 102 007a 9E81      		ldd r25,Y+6
 103 007c 853C      		cpi r24,-59
 104 007e F9E0      		ldi r31,9
 105 0080 9F07      		cpc r25,r31
 106 0082 04F0      		brlt .L4
  30:floorDetection.c **** 		// Left sensor is on border
  31:floorDetection.c **** 		/*char result[4];
  32:floorDetection.c **** 		intToHex(cliff_left, result);
  33:floorDetection.c **** 		set_Display(result);*/
  34:floorDetection.c **** 		
  35:floorDetection.c **** 		*type = BORDER_LEFT;
 107               		.loc 1 35 0
 108 0084 8985      		ldd r24,Y+9
 109 0086 9A85      		ldd r25,Y+10
 110 0088 21E0      		ldi r18,lo8(1)
 111 008a FC01      		movw r30,r24
 112 008c 2083      		st Z,r18
  36:floorDetection.c **** 		
  37:floorDetection.c **** 		return;
 113               		.loc 1 37 0
 114 008e 00C0      		rjmp .L1
 115               	.L4:
  38:floorDetection.c **** 	} else if (cliff_right > BORDER_CLIFF_THRESHOLD) {
 116               		.loc 1 38 0
 117 0090 8F81      		ldd r24,Y+7
 118 0092 9885      		ldd r25,Y+8
 119 0094 853C      		cpi r24,-59
 120 0096 F9E0      		ldi r31,9
 121 0098 9F07      		cpc r25,r31
 122 009a 04F0      		brlt .L5
  39:floorDetection.c **** 		/*char result[4];
  40:floorDetection.c **** 		intToHex(cliff_left, result);
  41:floorDetection.c **** 		set_Display(result);*/
  42:floorDetection.c **** 		
  43:floorDetection.c **** 		*type = BORDER_RIGHT;
 123               		.loc 1 43 0
 124 009c 8985      		ldd r24,Y+9
 125 009e 9A85      		ldd r25,Y+10
 126 00a0 22E0      		ldi r18,lo8(2)
 127 00a2 FC01      		movw r30,r24
 128 00a4 2083      		st Z,r18
  44:floorDetection.c **** 		
  45:floorDetection.c **** 		return;
 129               		.loc 1 45 0
 130 00a6 00C0      		rjmp .L1
 131               	.L5:
  46:floorDetection.c **** 	}
  47:floorDetection.c **** 	
  48:floorDetection.c **** 	*type = NO_TYPE;
 132               		.loc 1 48 0
 133 00a8 8985      		ldd r24,Y+9
 134 00aa 9A85      		ldd r25,Y+10
 135 00ac 23E0      		ldi r18,lo8(3)
 136 00ae FC01      		movw r30,r24
 137 00b0 2083      		st Z,r18
 138               	.L1:
 139               	/* epilogue start */
  49:floorDetection.c **** }
 140               		.loc 1 49 0
 141 00b2 2C96      		adiw r28,12
 142 00b4 0FB6      		in __tmp_reg__,__SREG__
 143 00b6 F894      		cli
 144 00b8 DEBF      		out __SP_H__,r29
 145 00ba 0FBE      		out __SREG__,__tmp_reg__
 146 00bc CDBF      		out __SP_L__,r28
 147 00be DF91      		pop r29
 148 00c0 CF91      		pop r28
 149 00c2 0895      		ret
 150               		.cfi_endproc
 151               	.LFE1:
 153               	.Letext0:
 154               		.file 2 "/usr/lib/avr/include/stdint.h"
 155               		.file 3 "floorDetection.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 floorDetection.c
     /tmp/ccPSPt4F.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPSPt4F.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPSPt4F.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPSPt4F.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccPSPt4F.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPSPt4F.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPSPt4F.s:13     .text:0000000000000000 floorDetection

NO UNDEFINED SYMBOLS
