   1               		.file	"drivecontrol.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	drive_direction
  13               	drive_direction:
  14               	.LFB2:
  15               		.file 1 "drivecontrol.c"
   1:drivecontrol.c **** #include "roomba.h"
   2:drivecontrol.c **** #include "tools.h"
   3:drivecontrol.c **** #include "usart.h"
   4:drivecontrol.c **** #include <stdio.h>
   5:drivecontrol.c **** #include <stdlib.h>
   6:drivecontrol.c **** #include "remotecontrol.h"
   7:drivecontrol.c **** #include "drivecontrol.h"
   8:drivecontrol.c **** 
   9:drivecontrol.c **** /**
  10:drivecontrol.c ****  * \brief TODO
  11:drivecontrol.c ****  */
  12:drivecontrol.c **** void getCommand(remoteSignal type, int16_t actVel_right, int16_t actVel_left) {
  13:drivecontrol.c **** 	if (type == RACCELERATE) {
  14:drivecontrol.c **** 		drive_direction(actVel_right + ACC_BRAKE_CONSTANT, actVel_left + ACC_BRAKE_CONSTANT);
  15:drivecontrol.c **** 	} else if (type == RBRAKE) {
  16:drivecontrol.c **** 		drive_direction(actVel_right - ACC_BRAKE_CONSTANT, actVel_left - ACC_BRAKE_CONSTANT);
  17:drivecontrol.c **** 	} else if (type == RLEFT) {
  18:drivecontrol.c **** 		drive_direction(actVel_right + ACC_BRAKE_CONSTANT, actVel_left - ACC_BRAKE_CONSTANT);
  19:drivecontrol.c **** 	} else if (type == RRIGHT) {
  20:drivecontrol.c **** 		drive_direction(actVel_right - ACC_BRAKE_CONSTANT, actVel_left + ACC_BRAKE_CONSTANT);
  21:drivecontrol.c **** 	}
  22:drivecontrol.c **** }
  23:drivecontrol.c **** 
  24:drivecontrol.c **** /**
  25:drivecontrol.c ****  * \brief Drive and have the posibility to drive a corner
  26:drivecontrol.c ****  * 
  27:drivecontrol.c ****  * \param velocity_right
  28:drivecontrol.c ****  * \param velocity_left
  29:drivecontrol.c ****  */
  30:drivecontrol.c **** void drive_direction(int16_t velocity_right, int16_t velocity_left) {
  16               		.loc 1 30 0
  17               		.cfi_startproc
  18               	.LVL0:
  19 0000 0F93      		push r16
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 4
  22               		.cfi_offset 16, -3
  23 0002 1F93      		push r17
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 5
  26               		.cfi_offset 17, -4
  27 0004 CF93      		push r28
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 6
  30               		.cfi_offset 28, -5
  31 0006 DF93      		push r29
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 7
  34               		.cfi_offset 29, -6
  35               	/* prologue: function */
  36               	/* frame size = 0 */
  37               	/* stack size = 4 */
  38               	.L__stack_usage = 4
  39 0008 182F      		mov r17,r24
  40 000a 092F      		mov r16,r25
  41 000c C62F      		mov r28,r22
  42 000e D72F      		mov r29,r23
  31:drivecontrol.c **** 	send_byte_roomba(145);
  43               		.loc 1 31 0
  44 0010 81E9      		ldi r24,lo8(-111)
  45               	.LVL1:
  46 0012 0E94 0000 		call send_byte_roomba
  47               	.LVL2:
  32:drivecontrol.c **** 	
  33:drivecontrol.c **** 	uint8_t low = velocity_right;
  34:drivecontrol.c **** 	uint8_t high = (velocity_right >> 8);
  35:drivecontrol.c **** 	
  36:drivecontrol.c **** 	send_byte_roomba(high);
  48               		.loc 1 36 0
  49 0016 802F      		mov r24,r16
  50 0018 0E94 0000 		call send_byte_roomba
  51               	.LVL3:
  37:drivecontrol.c **** 	send_byte_roomba(low);
  52               		.loc 1 37 0
  53 001c 812F      		mov r24,r17
  54 001e 0E94 0000 		call send_byte_roomba
  55               	.LVL4:
  38:drivecontrol.c **** 	
  39:drivecontrol.c **** 	low = velocity_left;
  40:drivecontrol.c **** 	high = (velocity_left >> 8);
  41:drivecontrol.c **** 	
  42:drivecontrol.c **** 	send_byte_roomba(high);
  56               		.loc 1 42 0
  57 0022 8D2F      		mov r24,r29
  58 0024 0E94 0000 		call send_byte_roomba
  59               	.LVL5:
  43:drivecontrol.c **** 	send_byte_roomba(low);
  60               		.loc 1 43 0
  61 0028 8C2F      		mov r24,r28
  62 002a 0E94 0000 		call send_byte_roomba
  63               	.LVL6:
  64               	/* epilogue start */
  44:drivecontrol.c **** }
  65               		.loc 1 44 0
  66 002e DF91      		pop r29
  67               	.LVL7:
  68 0030 CF91      		pop r28
  69               	.LVL8:
  70 0032 1F91      		pop r17
  71 0034 0F91      		pop r16
  72 0036 0895      		ret
  73               		.cfi_endproc
  74               	.LFE2:
  76               	.global	getCommand
  78               	getCommand:
  79               	.LFB1:
  12:drivecontrol.c **** void getCommand(remoteSignal type, int16_t actVel_right, int16_t actVel_left) {
  80               		.loc 1 12 0
  81               		.cfi_startproc
  82               	.LVL9:
  83               	/* prologue: function */
  84               	/* frame size = 0 */
  85               	/* stack size = 0 */
  86               	.L__stack_usage = 0
  87 0038 9B01      		movw r18,r22
  13:drivecontrol.c **** 	if (type == RACCELERATE) {
  88               		.loc 1 13 0
  89 003a 8111      		cpse r24,__zero_reg__
  90 003c 00C0      		rjmp .L3
  14:drivecontrol.c **** 		drive_direction(actVel_right + ACC_BRAKE_CONSTANT, actVel_left + ACC_BRAKE_CONSTANT);
  91               		.loc 1 14 0
  92 003e BA01      		movw r22,r20
  93               	.LVL10:
  94 0040 665F      		subi r22,-10
  95 0042 7F4F      		sbci r23,-1
  96 0044 C901      		movw r24,r18
  97               	.LVL11:
  98 0046 0A96      		adiw r24,10
  99 0048 0E94 0000 		call drive_direction
 100               	.LVL12:
 101 004c 0895      		ret
 102               	.LVL13:
 103               	.L3:
  15:drivecontrol.c **** 	} else if (type == RBRAKE) {
 104               		.loc 1 15 0
 105 004e 8130      		cpi r24,lo8(1)
 106 0050 01F4      		brne .L5
  16:drivecontrol.c **** 		drive_direction(actVel_right - ACC_BRAKE_CONSTANT, actVel_left - ACC_BRAKE_CONSTANT);
 107               		.loc 1 16 0
 108 0052 BA01      		movw r22,r20
 109 0054 6A50      		subi r22,10
 110 0056 7109      		sbc r23,__zero_reg__
 111 0058 C901      		movw r24,r18
 112               	.LVL14:
 113 005a 0A97      		sbiw r24,10
 114 005c 0E94 0000 		call drive_direction
 115               	.LVL15:
 116 0060 0895      		ret
 117               	.LVL16:
 118               	.L5:
  17:drivecontrol.c **** 	} else if (type == RLEFT) {
 119               		.loc 1 17 0
 120 0062 8230      		cpi r24,lo8(2)
 121 0064 01F4      		brne .L6
  18:drivecontrol.c **** 		drive_direction(actVel_right + ACC_BRAKE_CONSTANT, actVel_left - ACC_BRAKE_CONSTANT);
 122               		.loc 1 18 0
 123 0066 BA01      		movw r22,r20
 124 0068 6A50      		subi r22,10
 125 006a 7109      		sbc r23,__zero_reg__
 126 006c C901      		movw r24,r18
 127               	.LVL17:
 128 006e 0A96      		adiw r24,10
 129 0070 0E94 0000 		call drive_direction
 130               	.LVL18:
 131 0074 0895      		ret
 132               	.LVL19:
 133               	.L6:
  19:drivecontrol.c **** 	} else if (type == RRIGHT) {
 134               		.loc 1 19 0
 135 0076 8330      		cpi r24,lo8(3)
 136 0078 01F4      		brne .L2
  20:drivecontrol.c **** 		drive_direction(actVel_right - ACC_BRAKE_CONSTANT, actVel_left + ACC_BRAKE_CONSTANT);
 137               		.loc 1 20 0
 138 007a BA01      		movw r22,r20
 139 007c 665F      		subi r22,-10
 140 007e 7F4F      		sbci r23,-1
 141 0080 C901      		movw r24,r18
 142               	.LVL20:
 143 0082 0A97      		sbiw r24,10
 144 0084 0E94 0000 		call drive_direction
 145               	.LVL21:
 146               	.L2:
 147 0088 0895      		ret
 148               		.cfi_endproc
 149               	.LFE1:
 151               	.Letext0:
 152               		.file 2 "/usr/lib/avr/include/stdint.h"
 153               		.file 3 "remotecontrol.h"
 154               		.file 4 "usart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 drivecontrol.c
     /tmp/ccqbyTrJ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqbyTrJ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqbyTrJ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqbyTrJ.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccqbyTrJ.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqbyTrJ.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqbyTrJ.s:13     .text:0000000000000000 drive_direction
     /tmp/ccqbyTrJ.s:78     .text:0000000000000038 getCommand

UNDEFINED SYMBOLS
send_byte_roomba
