   1               		.file	"tools.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	my_msleep
  13               	my_msleep:
  14               	.LFB2:
  15               		.file 1 "tools.c"
   1:tools.c       **** #include <tools.h>
   2:tools.c       **** #include <util/delay_basic.h>
   3:tools.c       **** #include "avr/interrupt.h"
   4:tools.c       **** 
   5:tools.c       **** void my_msleep(uint16_t ms) {
  16               		.loc 1 5 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23               	.LBB5:
   6:tools.c       **** 		for (uint16_t a = 0; a < ms; a++) {
  24               		.loc 1 6 0
  25 0000 0097      		sbiw r24,0
  26 0002 01F0      		breq .L1
  27 0004 20E0      		ldi r18,0
  28 0006 30E0      		ldi r19,0
  29               	.LBB6:
  30               	.LBB7:
  31               		.file 2 "/usr/lib/avr/include/util/delay_basic.h"
   1:/usr/lib/avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/avr/include/util/delay_basic.h **** 
   5:/usr/lib/avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/util/delay_basic.h **** 
   8:/usr/lib/avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/util/delay_basic.h **** 
  11:/usr/lib/avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/avr/include/util/delay_basic.h **** 
  16:/usr/lib/avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/util/delay_basic.h **** 
  20:/usr/lib/avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/util/delay_basic.h **** 
  32:/usr/lib/avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/lib/avr/include/util/delay_basic.h **** 
  34:/usr/lib/avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/avr/include/util/delay_basic.h **** 
  37:/usr/lib/avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/avr/include/util/delay_basic.h **** 
  39:/usr/lib/avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/avr/include/util/delay_basic.h **** 
  44:/usr/lib/avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/avr/include/util/delay_basic.h **** 
  50:/usr/lib/avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/avr/include/util/delay_basic.h **** 
  58:/usr/lib/avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/avr/include/util/delay_basic.h **** 
  65:/usr/lib/avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/avr/include/util/delay_basic.h **** 
  67:/usr/lib/avr/include/util/delay_basic.h **** */
  68:/usr/lib/avr/include/util/delay_basic.h **** 
  69:/usr/lib/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/avr/include/util/delay_basic.h **** 
  71:/usr/lib/avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/avr/include/util/delay_basic.h **** 
  77:/usr/lib/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/avr/include/util/delay_basic.h **** */
  80:/usr/lib/avr/include/util/delay_basic.h **** void
  81:/usr/lib/avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/avr/include/util/delay_basic.h **** {
  83:/usr/lib/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/avr/include/util/delay_basic.h **** }
  90:/usr/lib/avr/include/util/delay_basic.h **** 
  91:/usr/lib/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/avr/include/util/delay_basic.h **** 
  93:/usr/lib/avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/avr/include/util/delay_basic.h **** 
  99:/usr/lib/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/avr/include/util/delay_basic.h ****  */
 102:/usr/lib/avr/include/util/delay_basic.h **** void
 103:/usr/lib/avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/avr/include/util/delay_basic.h **** {
 105:/usr/lib/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  32               		.loc 2 105 0
  33 0008 40EA      		ldi r20,lo8(-96)
  34 000a 5FE0      		ldi r21,lo8(15)
  35               	.LVL1:
  36               	.L3:
  37 000c FA01      		movw r30,r20
  38               	/* #APP */
  39               	 ;  105 "/usr/lib/avr/include/util/delay_basic.h" 1
  40 000e 3197      		1: sbiw r30,1
  41 0010 01F4      		brne 1b
  42               	 ;  0 "" 2
  43               	.LVL2:
  44               	/* #NOAPP */
  45               	.LBE7:
  46               	.LBE6:
  47               		.loc 1 6 0
  48 0012 2F5F      		subi r18,-1
  49 0014 3F4F      		sbci r19,-1
  50               	.LVL3:
  51 0016 2817      		cp r18,r24
  52 0018 3907      		cpc r19,r25
  53 001a 01F4      		brne .L3
  54               	.LVL4:
  55               	.L1:
  56 001c 0895      		ret
  57               	.LBE5:
  58               		.cfi_endproc
  59               	.LFE2:
  61               	.global	initializeTimer
  63               	initializeTimer:
  64               	.LFB3:
   7:tools.c       **** 			_delay_loop_2(4000);
   8:tools.c       **** 		}
   9:tools.c       **** }
  10:tools.c       **** 
  11:tools.c       **** void initializeTimer(uint16_t ms) {
  65               		.loc 1 11 0
  66               		.cfi_startproc
  67               	.LVL5:
  68               	/* prologue: function */
  69               	/* frame size = 0 */
  70               	/* stack size = 0 */
  71               	.L__stack_usage = 0
  12:tools.c       **** 	uint16_t timerval = ms / 1000 * 15625;
  72               		.loc 1 12 0
  73 001e 9C01      		movw r18,r24
  74 0020 3695      		lsr r19
  75 0022 2795      		ror r18
  76 0024 3695      		lsr r19
  77 0026 2795      		ror r18
  78 0028 3695      		lsr r19
  79 002a 2795      		ror r18
  80 002c A5EC      		ldi r26,lo8(-59)
  81 002e B0E2      		ldi r27,lo8(32)
  82 0030 0E94 0000 		call __umulhisi3
  83               	.LVL6:
  84 0034 9295      		swap r25
  85 0036 8295      		swap r24
  86 0038 8F70      		andi r24,0x0f
  87 003a 8927      		eor r24,r25
  88 003c 9F70      		andi r25,0x0f
  89 003e 8927      		eor r24,r25
  90 0040 49E0      		ldi r20,lo8(9)
  91 0042 5DE3      		ldi r21,lo8(61)
  92 0044 849F      		mul r24,r20
  93 0046 9001      		movw r18,r0
  94 0048 859F      		mul r24,r21
  95 004a 300D      		add r19,r0
  96 004c 949F      		mul r25,r20
  97 004e 300D      		add r19,r0
  98 0050 1124      		clr r1
  99               	.LVL7:
  13:tools.c       **** 	
  14:tools.c       **** 	// Initalize timer with CTC and 1024 as divider
  15:tools.c       **** 	TCCR1B = CTC_1024;
 100               		.loc 1 15 0
 101 0052 8DE0      		ldi r24,lo8(13)
 102 0054 8093 8100 		sts 129,r24
  16:tools.c       **** 	
  17:tools.c       **** 	OCR1AH = (timerval & 0xFF00) >> 8;
 103               		.loc 1 17 0
 104 0058 3093 8900 		sts 137,r19
  18:tools.c       **** 	OCR1AL = (timerval & 0x00FF);
 105               		.loc 1 18 0
 106 005c 2093 8800 		sts 136,r18
  19:tools.c       **** 		
  20:tools.c       **** 	// Activate interrupts
  21:tools.c       **** 	TIMSK1 = 0x03;
 107               		.loc 1 21 0
 108 0060 83E0      		ldi r24,lo8(3)
 109 0062 8093 6F00 		sts 111,r24
 110 0066 0895      		ret
 111               		.cfi_endproc
 112               	.LFE3:
 114               	.global	__vector_17
 116               	__vector_17:
 117               	.LFB4:
  22:tools.c       **** }
  23:tools.c       **** 
  24:tools.c       **** ISR(TIMER1_COMPA_vect) {
 118               		.loc 1 24 0
 119               		.cfi_startproc
 120 0068 1F92      		push r1
 121               	.LCFI0:
 122               		.cfi_def_cfa_offset 4
 123               		.cfi_offset 1, -3
 124 006a 0F92      		push r0
 125               	.LCFI1:
 126               		.cfi_def_cfa_offset 5
 127               		.cfi_offset 0, -4
 128 006c 0FB6      		in r0,__SREG__
 129 006e 0F92      		push r0
 130 0070 1124      		clr __zero_reg__
 131               	/* prologue: Signal */
 132               	/* frame size = 0 */
 133               	/* stack size = 3 */
 134               	.L__stack_usage = 3
  25:tools.c       **** 	cli();
 135               		.loc 1 25 0
 136               	/* #APP */
 137               	 ;  25 "tools.c" 1
 138 0072 F894      		cli
 139               	 ;  0 "" 2
  26:tools.c       **** 	// Do stuff when timer caused interrupt
  27:tools.c       **** 	sei();
 140               		.loc 1 27 0
 141               	 ;  27 "tools.c" 1
 142 0074 7894      		sei
 143               	 ;  0 "" 2
 144               	/* epilogue start */
  28:tools.c       **** }
 145               		.loc 1 28 0
 146               	/* #NOAPP */
 147 0076 0F90      		pop r0
 148 0078 0FBE      		out __SREG__,r0
 149 007a 0F90      		pop r0
 150 007c 1F90      		pop r1
 151 007e 1895      		reti
 152               		.cfi_endproc
 153               	.LFE4:
 155               	.global	concat_bytes
 157               	concat_bytes:
 158               	.LFB5:
  29:tools.c       **** 
  30:tools.c       **** /**
  31:tools.c       ****  * \brief Concats two bytes from the array data [0] and [1] to one 
  32:tools.c       ****  * 		  binary value
  33:tools.c       ****  * 
  34:tools.c       ****  * \param data high and low byte on [0] and [1] of the array
  35:tools.c       ****  * \return the concatenated high and low byte as value
  36:tools.c       ****  */
  37:tools.c       **** uint16_t concat_bytes(uint8_t *data) {
 159               		.loc 1 37 0
 160               		.cfi_startproc
 161               	.LVL8:
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 166 0080 FC01      		movw r30,r24
  38:tools.c       **** 	uint16_t value = data[0] << 8;
 167               		.loc 1 38 0
 168 0082 8081      		ld r24,Z
 169               	.LVL9:
 170 0084 90E0      		ldi r25,0
 171 0086 982F      		mov r25,r24
 172 0088 8827      		clr r24
 173               	.LVL10:
  39:tools.c       **** 	value |= data[1];
 174               		.loc 1 39 0
 175 008a 2181      		ldd r18,Z+1
  40:tools.c       **** 	
  41:tools.c       **** 	return value;
  42:tools.c       **** }
 176               		.loc 1 42 0
 177 008c 822B      		or r24,r18
 178               	.LVL11:
 179 008e 0895      		ret
 180               		.cfi_endproc
 181               	.LFE5:
 183               	.Letext0:
 184               		.file 3 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tools.c
     /tmp/ccre4nNR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccre4nNR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccre4nNR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccre4nNR.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccre4nNR.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccre4nNR.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccre4nNR.s:13     .text:0000000000000000 my_msleep
     /tmp/ccre4nNR.s:63     .text:000000000000001e initializeTimer
     /tmp/ccre4nNR.s:116    .text:0000000000000068 __vector_17
     /tmp/ccre4nNR.s:157    .text:0000000000000080 concat_bytes

UNDEFINED SYMBOLS
__umulhisi3
