   1               		.file	"roomba.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	initializeRoomba
  13               	initializeRoomba:
  14               	.LFB1:
  15               		.file 1 "roomba.c"
   1:roomba.c      **** #include "roomba.h"
   2:roomba.c      **** #include "tools.h"
   3:roomba.c      **** #include "usart.h"
   4:roomba.c      **** #include <stdio.h>
   5:roomba.c      **** #include <stdlib.h>
   6:roomba.c      **** 
   7:roomba.c      **** void initializeRoomba(void) {
  16               		.loc 1 7 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
   8:roomba.c      **** 	// Start command
   9:roomba.c      **** 	send_byte_roomba(128);
  22               		.loc 1 9 0
  23 0000 80E8      		ldi r24,lo8(-128)
  24 0002 0E94 0000 		call send_byte_roomba
  25               	.LVL0:
  10:roomba.c      **** 		
  11:roomba.c      **** 	// Save mode
  12:roomba.c      **** 	send_byte_roomba(131);
  26               		.loc 1 12 0
  27 0006 83E8      		ldi r24,lo8(-125)
  28 0008 0E94 0000 		call send_byte_roomba
  29               	.LVL1:
  30 000c 0895      		ret
  31               		.cfi_endproc
  32               	.LFE1:
  34               	.global	set_Display
  36               	set_Display:
  37               	.LFB2:
  13:roomba.c      **** }
  14:roomba.c      **** 
  15:roomba.c      **** void set_Display(char *data) {
  38               		.loc 1 15 0
  39               		.cfi_startproc
  40               	.LVL2:
  41 000e 0F93      		push r16
  42               	.LCFI0:
  43               		.cfi_def_cfa_offset 4
  44               		.cfi_offset 16, -3
  45 0010 1F93      		push r17
  46               	.LCFI1:
  47               		.cfi_def_cfa_offset 5
  48               		.cfi_offset 17, -4
  49 0012 CF93      		push r28
  50               	.LCFI2:
  51               		.cfi_def_cfa_offset 6
  52               		.cfi_offset 28, -5
  53 0014 DF93      		push r29
  54               	.LCFI3:
  55               		.cfi_def_cfa_offset 7
  56               		.cfi_offset 29, -6
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 4 */
  60               	.L__stack_usage = 4
  61 0016 082F      		mov r16,r24
  62 0018 192F      		mov r17,r25
  16:roomba.c      **** 	send_byte_roomba(164);
  63               		.loc 1 16 0
  64 001a 84EA      		ldi r24,lo8(-92)
  65               	.LVL3:
  66 001c 0E94 0000 		call send_byte_roomba
  67               	.LVL4:
  68 0020 C02F      		mov r28,r16
  69 0022 D12F      		mov r29,r17
  17:roomba.c      **** 	
  18:roomba.c      **** 	uint8_t a = 0;
  70               		.loc 1 18 0
  71 0024 10E0      		ldi r17,0
  72               	.LVL5:
  73               	.L4:
  19:roomba.c      **** 	while (a < 4) {
  20:roomba.c      **** 		send_byte_roomba(data[a]);
  74               		.loc 1 20 0
  75 0026 8991      		ld r24,Y+
  76 0028 0E94 0000 		call send_byte_roomba
  77               	.LVL6:
  21:roomba.c      **** 		a++;
  78               		.loc 1 21 0
  79 002c 1F5F      		subi r17,lo8(-(1))
  80               	.LVL7:
  19:roomba.c      **** 	while (a < 4) {
  81               		.loc 1 19 0
  82 002e 1430      		cpi r17,lo8(4)
  83 0030 01F4      		brne .L4
  84               	/* epilogue start */
  22:roomba.c      **** 	}
  23:roomba.c      **** }
  85               		.loc 1 23 0
  86 0032 DF91      		pop r29
  87 0034 CF91      		pop r28
  88 0036 1F91      		pop r17
  89               	.LVL8:
  90 0038 0F91      		pop r16
  91 003a 0895      		ret
  92               		.cfi_endproc
  93               	.LFE2:
  95               	.global	read_button
  97               	read_button:
  98               	.LFB3:
  24:roomba.c      **** 
  25:roomba.c      **** /**
  26:roomba.c      ****  * \brief Find out if a button on the roomba was pressed
  27:roomba.c      ****  * 
  28:roomba.c      ****  * \param button a constant fromm roomba.h e.g HOUR
  29:roomba.c      ****  * \return 0 if button was not pressed, 1 instead
  30:roomba.c      ****  */
  31:roomba.c      **** uint8_t read_button(uint8_t button) {
  99               		.loc 1 31 0
 100               		.cfi_startproc
 101               	.LVL9:
 102 003c CF93      		push r28
 103               	.LCFI4:
 104               		.cfi_def_cfa_offset 4
 105               		.cfi_offset 28, -3
 106               	/* prologue: function */
 107               	/* frame size = 0 */
 108               	/* stack size = 1 */
 109               	.L__stack_usage = 1
 110 003e C82F      		mov r28,r24
  32:roomba.c      **** 	// Get sensor packets
  33:roomba.c      **** 	send_byte_roomba(142);
 111               		.loc 1 33 0
 112 0040 8EE8      		ldi r24,lo8(-114)
 113               	.LVL10:
 114 0042 0E94 0000 		call send_byte_roomba
 115               	.LVL11:
  34:roomba.c      **** 	
  35:roomba.c      **** 	// Buttons
  36:roomba.c      **** 	send_byte_roomba(18); 
 116               		.loc 1 36 0
 117 0046 82E1      		ldi r24,lo8(18)
 118 0048 0E94 0000 		call send_byte_roomba
 119               	.LVL12:
  37:roomba.c      **** 	
  38:roomba.c      **** 	uint8_t result = receive_byte_roomba();
 120               		.loc 1 38 0
 121 004c 0E94 0000 		call receive_byte_roomba
 122               	.LVL13:
  39:roomba.c      **** 	
  40:roomba.c      **** 	if ((result & button) == button) {
 123               		.loc 1 40 0
 124 0050 982F      		mov r25,r24
 125 0052 9C23      		and r25,r28
 126 0054 81E0      		ldi r24,lo8(1)
 127               	.LVL14:
 128 0056 C913      		cpse r28,r25
 129 0058 80E0      		ldi r24,0
 130               	.L6:
 131               	/* epilogue start */
  41:roomba.c      **** 		return 1;
  42:roomba.c      **** 	}
  43:roomba.c      **** 	
  44:roomba.c      **** 	return 0;
  45:roomba.c      **** }
 132               		.loc 1 45 0
 133 005a CF91      		pop r28
 134               	.LVL15:
 135 005c 0895      		ret
 136               		.cfi_endproc
 137               	.LFE3:
 139               	.global	read_values
 141               	read_values:
 142               	.LFB4:
  46:roomba.c      **** 
  47:roomba.c      **** /**
  48:roomba.c      ****  * \brief Read a sensor value
  49:roomba.c      ****  * 
  50:roomba.c      ****  * \param packetid the packetid corresponding to the sensor
  51:roomba.c      ****  * \param data an array where the returned bytes are stored
  52:roomba.c      ****  * \param length how many bytes should be retrieved
  53:roomba.c      ****  */
  54:roomba.c      **** void read_values(uint8_t packetid, uint8_t * data, uint8_t length) {
 143               		.loc 1 54 0
 144               		.cfi_startproc
 145               	.LVL16:
 146 005e FF92      		push r15
 147               	.LCFI5:
 148               		.cfi_def_cfa_offset 4
 149               		.cfi_offset 15, -3
 150 0060 0F93      		push r16
 151               	.LCFI6:
 152               		.cfi_def_cfa_offset 5
 153               		.cfi_offset 16, -4
 154 0062 1F93      		push r17
 155               	.LCFI7:
 156               		.cfi_def_cfa_offset 6
 157               		.cfi_offset 17, -5
 158 0064 CF93      		push r28
 159               	.LCFI8:
 160               		.cfi_def_cfa_offset 7
 161               		.cfi_offset 28, -6
 162 0066 DF93      		push r29
 163               	.LCFI9:
 164               		.cfi_def_cfa_offset 8
 165               		.cfi_offset 29, -7
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 5 */
 169               	.L__stack_usage = 5
 170 0068 C82F      		mov r28,r24
 171 006a F62E      		mov r15,r22
 172 006c 172F      		mov r17,r23
 173 006e 042F      		mov r16,r20
  55:roomba.c      **** 	send_byte_roomba(142);
 174               		.loc 1 55 0
 175 0070 8EE8      		ldi r24,lo8(-114)
 176               	.LVL17:
 177 0072 0E94 0000 		call send_byte_roomba
 178               	.LVL18:
  56:roomba.c      **** 	send_byte_roomba(packetid);
 179               		.loc 1 56 0
 180 0076 8C2F      		mov r24,r28
 181 0078 0E94 0000 		call send_byte_roomba
 182               	.LVL19:
 183               	.LBB2:
  57:roomba.c      **** 	
  58:roomba.c      **** 	for (uint8_t a = 0; a < length; a++) {
 184               		.loc 1 58 0
 185 007c 0023      		tst r16
 186 007e 01F0      		breq .L7
 187 0080 CF2D      		mov r28,r15
 188               	.LVL20:
 189 0082 D12F      		mov r29,r17
 190 0084 10E0      		ldi r17,0
 191               	.LVL21:
 192               	.L9:
  59:roomba.c      **** 		data[a] = receive_byte_roomba();
 193               		.loc 1 59 0 discriminator 2
 194 0086 0E94 0000 		call receive_byte_roomba
 195               	.LVL22:
 196 008a 8993      		st Y+,r24
  58:roomba.c      **** 	for (uint8_t a = 0; a < length; a++) {
 197               		.loc 1 58 0 discriminator 2
 198 008c 1F5F      		subi r17,lo8(-(1))
 199               	.LVL23:
 200 008e 1013      		cpse r17,r16
 201 0090 00C0      		rjmp .L9
 202               	.LVL24:
 203               	.L7:
 204               	/* epilogue start */
 205               	.LBE2:
  60:roomba.c      **** 	}
  61:roomba.c      **** }
 206               		.loc 1 61 0
 207 0092 DF91      		pop r29
 208 0094 CF91      		pop r28
 209 0096 1F91      		pop r17
 210 0098 0F91      		pop r16
 211               	.LVL25:
 212 009a FF90      		pop r15
 213 009c 0895      		ret
 214               		.cfi_endproc
 215               	.LFE4:
 217               	.global	drive
 219               	drive:
 220               	.LFB5:
  62:roomba.c      **** 
  63:roomba.c      **** /**
  64:roomba.c      ****  * \brief Let the roomba drive
  65:roomba.c      ****  * 
  66:roomba.c      ****  * \param velocity the velocity in mm/s. If negative --> backwards
  67:roomba.c      ****  */
  68:roomba.c      **** void drive(int16_t velocity) {
 221               		.loc 1 68 0
 222               		.cfi_startproc
 223               	.LVL26:
 224 009e CF93      		push r28
 225               	.LCFI10:
 226               		.cfi_def_cfa_offset 4
 227               		.cfi_offset 28, -3
 228 00a0 DF93      		push r29
 229               	.LCFI11:
 230               		.cfi_def_cfa_offset 5
 231               		.cfi_offset 29, -4
 232               	/* prologue: function */
 233               	/* frame size = 0 */
 234               	/* stack size = 2 */
 235               	.L__stack_usage = 2
 236 00a2 C82F      		mov r28,r24
 237 00a4 D92F      		mov r29,r25
  69:roomba.c      **** 	send_byte_roomba(145);
 238               		.loc 1 69 0
 239 00a6 81E9      		ldi r24,lo8(-111)
 240               	.LVL27:
 241 00a8 0E94 0000 		call send_byte_roomba
 242               	.LVL28:
  70:roomba.c      **** 	
  71:roomba.c      **** 	uint8_t low = velocity;
  72:roomba.c      **** 	uint8_t high = (velocity >> 8);
  73:roomba.c      **** 	
  74:roomba.c      **** 	send_byte_roomba(high);
 243               		.loc 1 74 0
 244 00ac 8D2F      		mov r24,r29
 245 00ae 0E94 0000 		call send_byte_roomba
 246               	.LVL29:
  75:roomba.c      **** 	send_byte_roomba(low);
 247               		.loc 1 75 0
 248 00b2 8C2F      		mov r24,r28
 249 00b4 0E94 0000 		call send_byte_roomba
 250               	.LVL30:
  76:roomba.c      **** 	
  77:roomba.c      **** 	send_byte_roomba(high);
 251               		.loc 1 77 0
 252 00b8 8D2F      		mov r24,r29
 253 00ba 0E94 0000 		call send_byte_roomba
 254               	.LVL31:
  78:roomba.c      **** 	send_byte_roomba(low);
 255               		.loc 1 78 0
 256 00be 8C2F      		mov r24,r28
 257 00c0 0E94 0000 		call send_byte_roomba
 258               	.LVL32:
 259               	/* epilogue start */
  79:roomba.c      **** }
 260               		.loc 1 79 0
 261 00c4 DF91      		pop r29
 262               	.LVL33:
 263 00c6 CF91      		pop r28
 264               	.LVL34:
 265 00c8 0895      		ret
 266               		.cfi_endproc
 267               	.LFE5:
 269               	.global	stop
 271               	stop:
 272               	.LFB6:
  80:roomba.c      **** 
  81:roomba.c      **** 
  82:roomba.c      **** 
  83:roomba.c      **** /**
  84:roomba.c      ****  * Stop the roomba
  85:roomba.c      ****  */
  86:roomba.c      **** void stop() {
 273               		.loc 1 86 0
 274               		.cfi_startproc
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
  87:roomba.c      **** 	drive(0);
 279               		.loc 1 87 0
 280 00ca 80E0      		ldi r24,0
 281 00cc 90E0      		ldi r25,0
 282 00ce 0E94 0000 		call drive
 283               	.LVL35:
 284 00d2 0895      		ret
 285               		.cfi_endproc
 286               	.LFE6:
 288               	.global	getTicks
 290               	getTicks:
 291               	.LFB9:
  88:roomba.c      **** }
  89:roomba.c      **** 
  90:roomba.c      **** /**
  91:roomba.c      ****  * \brief Drive the roomba
  92:roomba.c      ****  * 
  93:roomba.c      ****  * \param distance so far
  94:roomba.c      ****  * \param velocity with this velocity
  95:roomba.c      ****  */
  96:roomba.c      **** void drive_roomba(uint16_t distance, int16_t velocity) {
  97:roomba.c      **** 	// Start tick
  98:roomba.c      **** 	char buff[50];
  99:roomba.c      **** 	uint16_t start_value = getTicks();
 100:roomba.c      **** 	sprintf(buff, "Ticks-Start: %u\r\n", start_value);
 101:roomba.c      **** 	sendString(buff);
 102:roomba.c      **** 	
 103:roomba.c      **** 	drive(velocity);
 104:roomba.c      **** 	
 105:roomba.c      **** 	uint16_t sleep = distance / abs(velocity);
 106:roomba.c      **** 	my_msleep(sleep * 1000);
 107:roomba.c      **** 	
 108:roomba.c      **** 	stop();
 109:roomba.c      **** 	
 110:roomba.c      **** 	uint16_t end_value = getTicks();
 111:roomba.c      **** 	sprintf(buff, "Ticks-End: %u\r\n", end_value);
 112:roomba.c      **** 	sendString(buff);
 113:roomba.c      **** 	sprintf(buff, "Ticks: %u\r\n", (end_value - start_value));
 114:roomba.c      **** 	sendString(buff);
 115:roomba.c      **** 	
 116:roomba.c      **** 	// 1m = 2262 Ticks
 117:roomba.c      **** }
 118:roomba.c      **** 
 119:roomba.c      **** /**
 120:roomba.c      ****  * \brief Does the same like drive_roomba but more exact with counting ticks
 121:roomba.c      ****  */
 122:roomba.c      **** void drive_roomba_exact(uint16_t distance, int16_t velocity) {
 123:roomba.c      **** 	uint16_t start_value = getTicks();
 124:roomba.c      **** 	
 125:roomba.c      **** 	drive(velocity);
 126:roomba.c      **** 	
 127:roomba.c      **** 	char buff[50];
 128:roomba.c      **** 	sprintf(buff, "Ticks-Start: %u\r\n", start_value);
 129:roomba.c      **** 	sendString(buff);
 130:roomba.c      **** 	
 131:roomba.c      **** 	uint16_t maxTicks = (uint16_t) (distance * 2.262);
 132:roomba.c      **** 	sprintf(buff, "Max: %u\r\n", maxTicks);
 133:roomba.c      **** 	sendString(buff);
 134:roomba.c      **** 	
 135:roomba.c      **** 	my_msleep(200);
 136:roomba.c      **** 	
 137:roomba.c      **** 	while (1) {
 138:roomba.c      **** 		uint16_t ticks = getTicks();
 139:roomba.c      **** 		uint16_t distanceTicks;
 140:roomba.c      **** 		
 141:roomba.c      **** 		// Overflow
 142:roomba.c      **** 		if (ticks < start_value && velocity > 0) {
 143:roomba.c      **** 			distanceTicks = 65535 - start_value + ticks;
 144:roomba.c      **** 		} else if (ticks > start_value && velocity < 0) {
 145:roomba.c      **** 			distanceTicks = start_value + (65535 - ticks);
 146:roomba.c      **** 		} else {
 147:roomba.c      **** 			distanceTicks = abs(ticks - start_value);
 148:roomba.c      **** 		}
 149:roomba.c      **** 		
 150:roomba.c      **** 		if (distanceTicks > maxTicks) {
 151:roomba.c      **** 			break;
 152:roomba.c      **** 		}
 153:roomba.c      **** 	}
 154:roomba.c      **** 	
 155:roomba.c      **** 	stop();
 156:roomba.c      **** }
 157:roomba.c      **** 
 158:roomba.c      **** /**
 159:roomba.c      ****  * \brief Get the actual tick count for the left wheel
 160:roomba.c      ****  * 			(at the moment enough, as long as we only drive straight)
 161:roomba.c      ****  */
 162:roomba.c      **** uint16_t getTicks() {
 292               		.loc 1 162 0
 293               		.cfi_startproc
 294 00d4 CF93      		push r28
 295               	.LCFI12:
 296               		.cfi_def_cfa_offset 4
 297               		.cfi_offset 28, -3
 298 00d6 DF93      		push r29
 299               	.LCFI13:
 300               		.cfi_def_cfa_offset 5
 301               		.cfi_offset 29, -4
 302 00d8 1F92      		push __zero_reg__
 303 00da 1F92      		push __zero_reg__
 304               	.LCFI14:
 305               		.cfi_def_cfa_offset 7
 306 00dc CDB7      		in r28,__SP_L__
 307 00de DEB7      		in r29,__SP_H__
 308               	.LCFI15:
 309               		.cfi_def_cfa_register 28
 310               	/* prologue: function */
 311               	/* frame size = 2 */
 312               	/* stack size = 4 */
 313               	.L__stack_usage = 4
 163:roomba.c      **** 	uint8_t data[2];
 164:roomba.c      **** 	read_values(43, data, 2);
 314               		.loc 1 164 0
 315 00e0 42E0      		ldi r20,lo8(2)
 316 00e2 BE01      		movw r22,r28
 317 00e4 6F5F      		subi r22,-1
 318 00e6 7F4F      		sbci r23,-1
 319 00e8 8BE2      		ldi r24,lo8(43)
 320 00ea 0E94 0000 		call read_values
 321               	.LVL36:
 165:roomba.c      **** 	
 166:roomba.c      **** 	return concat_bytes(data);
 322               		.loc 1 166 0
 323 00ee CE01      		movw r24,r28
 324 00f0 0196      		adiw r24,1
 325 00f2 0E94 0000 		call concat_bytes
 326               	.LVL37:
 327               	/* epilogue start */
 167:roomba.c      **** }
 328               		.loc 1 167 0
 329 00f6 0F90      		pop __tmp_reg__
 330 00f8 0F90      		pop __tmp_reg__
 331 00fa DF91      		pop r29
 332 00fc CF91      		pop r28
 333 00fe 0895      		ret
 334               		.cfi_endproc
 335               	.LFE9:
 337               		.section	.rodata.str1.1,"aMS",@progbits,1
 338               	.LC1:
 339 0000 5469 636B 		.string	"Ticks-Start: %u\r\n"
 339      732D 5374 
 339      6172 743A 
 339      2025 750D 
 339      0A00 
 340               	.LC2:
 341 0012 5469 636B 		.string	"Ticks-End: %u\r\n"
 341      732D 456E 
 341      643A 2025 
 341      750D 0A00 
 342               	.LC3:
 343 0022 5469 636B 		.string	"Ticks: %u\r\n"
 343      733A 2025 
 343      750D 0A00 
 344               		.text
 345               	.global	drive_roomba
 347               	drive_roomba:
 348               	.LFB7:
  96:roomba.c      **** void drive_roomba(uint16_t distance, int16_t velocity) {
 349               		.loc 1 96 0
 350               		.cfi_startproc
 351               	.LVL38:
 352 0100 AF92      		push r10
 353               	.LCFI16:
 354               		.cfi_def_cfa_offset 4
 355               		.cfi_offset 10, -3
 356 0102 BF92      		push r11
 357               	.LCFI17:
 358               		.cfi_def_cfa_offset 5
 359               		.cfi_offset 11, -4
 360 0104 CF92      		push r12
 361               	.LCFI18:
 362               		.cfi_def_cfa_offset 6
 363               		.cfi_offset 12, -5
 364 0106 DF92      		push r13
 365               	.LCFI19:
 366               		.cfi_def_cfa_offset 7
 367               		.cfi_offset 13, -6
 368 0108 EF92      		push r14
 369               	.LCFI20:
 370               		.cfi_def_cfa_offset 8
 371               		.cfi_offset 14, -7
 372 010a FF92      		push r15
 373               	.LCFI21:
 374               		.cfi_def_cfa_offset 9
 375               		.cfi_offset 15, -8
 376 010c 0F93      		push r16
 377               	.LCFI22:
 378               		.cfi_def_cfa_offset 10
 379               		.cfi_offset 16, -9
 380 010e 1F93      		push r17
 381               	.LCFI23:
 382               		.cfi_def_cfa_offset 11
 383               		.cfi_offset 17, -10
 384 0110 CF93      		push r28
 385               	.LCFI24:
 386               		.cfi_def_cfa_offset 12
 387               		.cfi_offset 28, -11
 388 0112 DF93      		push r29
 389               	.LCFI25:
 390               		.cfi_def_cfa_offset 13
 391               		.cfi_offset 29, -12
 392 0114 CDB7      		in r28,__SP_L__
 393 0116 DEB7      		in r29,__SP_H__
 394               	.LCFI26:
 395               		.cfi_def_cfa_register 28
 396 0118 E297      		sbiw r28,50
 397               	.LCFI27:
 398               		.cfi_def_cfa_offset 63
 399 011a 0FB6      		in __tmp_reg__,__SREG__
 400 011c F894      		cli
 401 011e DEBF      		out __SP_H__,r29
 402 0120 0FBE      		out __SREG__,__tmp_reg__
 403 0122 CDBF      		out __SP_L__,r28
 404               	/* prologue: function */
 405               	/* frame size = 50 */
 406               	/* stack size = 60 */
 407               	.L__stack_usage = 60
 408 0124 5C01      		movw r10,r24
 409 0126 6B01      		movw r12,r22
  99:roomba.c      **** 	uint16_t start_value = getTicks();
 410               		.loc 1 99 0
 411 0128 0E94 0000 		call getTicks
 412               	.LVL39:
 413 012c 7C01      		movw r14,r24
 414               	.LVL40:
 100:roomba.c      **** 	sprintf(buff, "Ticks-Start: %u\r\n", start_value);
 415               		.loc 1 100 0
 416 012e FF92      		push r15
 417 0130 8F93      		push r24
 418 0132 80E0      		ldi r24,lo8(.LC1)
 419 0134 90E0      		ldi r25,hi8(.LC1)
 420 0136 9F93      		push r25
 421 0138 8F93      		push r24
 422 013a 8E01      		movw r16,r28
 423 013c 0F5F      		subi r16,-1
 424 013e 1F4F      		sbci r17,-1
 425 0140 1F93      		push r17
 426 0142 0F93      		push r16
 427 0144 0E94 0000 		call sprintf
 428               	.LVL41:
 101:roomba.c      **** 	sendString(buff);
 429               		.loc 1 101 0
 430 0148 C801      		movw r24,r16
 431 014a 0E94 0000 		call sendString
 432               	.LVL42:
 103:roomba.c      **** 	drive(velocity);
 433               		.loc 1 103 0
 434 014e C601      		movw r24,r12
 435 0150 0E94 0000 		call drive
 436               	.LVL43:
 105:roomba.c      **** 	uint16_t sleep = distance / abs(velocity);
 437               		.loc 1 105 0
 438 0154 B601      		movw r22,r12
 439 0156 DD20      		tst r13
 440 0158 04F4      		brge .L14
 441 015a 6627      		clr r22
 442 015c 7727      		clr r23
 443 015e 6C19      		sub r22,r12
 444 0160 7D09      		sbc r23,r13
 445               	.L14:
 446 0162 C501      		movw r24,r10
 447 0164 0E94 0000 		call __udivmodhi4
 106:roomba.c      **** 	my_msleep(sleep * 1000);
 448               		.loc 1 106 0
 449 0168 88EE      		ldi r24,lo8(-24)
 450 016a 93E0      		ldi r25,lo8(3)
 451 016c 9C01      		movw r18,r24
 452 016e 629F      		mul r22,r18
 453 0170 C001      		movw r24,r0
 454 0172 639F      		mul r22,r19
 455 0174 900D      		add r25,r0
 456 0176 729F      		mul r23,r18
 457 0178 900D      		add r25,r0
 458 017a 1124      		clr r1
 459 017c 0E94 0000 		call my_msleep
 460               	.LVL44:
 108:roomba.c      **** 	stop();
 461               		.loc 1 108 0
 462 0180 0E94 0000 		call stop
 463               	.LVL45:
 110:roomba.c      **** 	uint16_t end_value = getTicks();
 464               		.loc 1 110 0
 465 0184 0E94 0000 		call getTicks
 466               	.LVL46:
 467 0188 6C01      		movw r12,r24
 468               	.LVL47:
 111:roomba.c      **** 	sprintf(buff, "Ticks-End: %u\r\n", end_value);
 469               		.loc 1 111 0
 470 018a DF92      		push r13
 471 018c 8F93      		push r24
 472 018e 80E0      		ldi r24,lo8(.LC2)
 473 0190 90E0      		ldi r25,hi8(.LC2)
 474 0192 9F93      		push r25
 475 0194 8F93      		push r24
 476 0196 8E01      		movw r16,r28
 477 0198 0F5F      		subi r16,-1
 478 019a 1F4F      		sbci r17,-1
 479 019c 1F93      		push r17
 480 019e 0F93      		push r16
 481 01a0 0E94 0000 		call sprintf
 482               	.LVL48:
 112:roomba.c      **** 	sendString(buff);
 483               		.loc 1 112 0
 484 01a4 C801      		movw r24,r16
 485 01a6 0E94 0000 		call sendString
 486               	.LVL49:
 113:roomba.c      **** 	sprintf(buff, "Ticks: %u\r\n", (end_value - start_value));
 487               		.loc 1 113 0
 488 01aa CE18      		sub r12,r14
 489 01ac DF08      		sbc r13,r15
 490               	.LVL50:
 491 01ae DF92      		push r13
 492 01b0 CF92      		push r12
 493 01b2 80E0      		ldi r24,lo8(.LC3)
 494 01b4 90E0      		ldi r25,hi8(.LC3)
 495 01b6 9F93      		push r25
 496 01b8 8F93      		push r24
 497 01ba 1F93      		push r17
 498 01bc 0F93      		push r16
 499 01be 0E94 0000 		call sprintf
 500               	.LVL51:
 114:roomba.c      **** 	sendString(buff);
 501               		.loc 1 114 0
 502 01c2 C801      		movw r24,r16
 503 01c4 0E94 0000 		call sendString
 504               	.LVL52:
 505 01c8 0FB6      		in __tmp_reg__,__SREG__
 506 01ca F894      		cli
 507 01cc DEBF      		out __SP_H__,r29
 508 01ce 0FBE      		out __SREG__,__tmp_reg__
 509 01d0 CDBF      		out __SP_L__,r28
 510               	/* epilogue start */
 117:roomba.c      **** }
 511               		.loc 1 117 0
 512 01d2 E296      		adiw r28,50
 513 01d4 0FB6      		in __tmp_reg__,__SREG__
 514 01d6 F894      		cli
 515 01d8 DEBF      		out __SP_H__,r29
 516 01da 0FBE      		out __SREG__,__tmp_reg__
 517 01dc CDBF      		out __SP_L__,r28
 518 01de DF91      		pop r29
 519 01e0 CF91      		pop r28
 520 01e2 1F91      		pop r17
 521 01e4 0F91      		pop r16
 522 01e6 FF90      		pop r15
 523 01e8 EF90      		pop r14
 524               	.LVL53:
 525 01ea DF90      		pop r13
 526 01ec CF90      		pop r12
 527 01ee BF90      		pop r11
 528 01f0 AF90      		pop r10
 529               	.LVL54:
 530 01f2 0895      		ret
 531               		.cfi_endproc
 532               	.LFE7:
 534               	.global	__floatunsisf
 535               	.global	__mulsf3
 536               	.global	__fixunssfsi
 537               		.section	.rodata.str1.1
 538               	.LC4:
 539 002e 4D61 783A 		.string	"Max: %u\r\n"
 539      2025 750D 
 539      0A00 
 540               		.text
 541               	.global	drive_roomba_exact
 543               	drive_roomba_exact:
 544               	.LFB8:
 122:roomba.c      **** void drive_roomba_exact(uint16_t distance, int16_t velocity) {
 545               		.loc 1 122 0
 546               		.cfi_startproc
 547               	.LVL55:
 548 01f4 8F92      		push r8
 549               	.LCFI28:
 550               		.cfi_def_cfa_offset 4
 551               		.cfi_offset 8, -3
 552 01f6 9F92      		push r9
 553               	.LCFI29:
 554               		.cfi_def_cfa_offset 5
 555               		.cfi_offset 9, -4
 556 01f8 AF92      		push r10
 557               	.LCFI30:
 558               		.cfi_def_cfa_offset 6
 559               		.cfi_offset 10, -5
 560 01fa BF92      		push r11
 561               	.LCFI31:
 562               		.cfi_def_cfa_offset 7
 563               		.cfi_offset 11, -6
 564 01fc CF92      		push r12
 565               	.LCFI32:
 566               		.cfi_def_cfa_offset 8
 567               		.cfi_offset 12, -7
 568 01fe DF92      		push r13
 569               	.LCFI33:
 570               		.cfi_def_cfa_offset 9
 571               		.cfi_offset 13, -8
 572 0200 EF92      		push r14
 573               	.LCFI34:
 574               		.cfi_def_cfa_offset 10
 575               		.cfi_offset 14, -9
 576 0202 FF92      		push r15
 577               	.LCFI35:
 578               		.cfi_def_cfa_offset 11
 579               		.cfi_offset 15, -10
 580 0204 0F93      		push r16
 581               	.LCFI36:
 582               		.cfi_def_cfa_offset 12
 583               		.cfi_offset 16, -11
 584 0206 1F93      		push r17
 585               	.LCFI37:
 586               		.cfi_def_cfa_offset 13
 587               		.cfi_offset 17, -12
 588 0208 CF93      		push r28
 589               	.LCFI38:
 590               		.cfi_def_cfa_offset 14
 591               		.cfi_offset 28, -13
 592 020a DF93      		push r29
 593               	.LCFI39:
 594               		.cfi_def_cfa_offset 15
 595               		.cfi_offset 29, -14
 596 020c CDB7      		in r28,__SP_L__
 597 020e DEB7      		in r29,__SP_H__
 598               	.LCFI40:
 599               		.cfi_def_cfa_register 28
 600 0210 E297      		sbiw r28,50
 601               	.LCFI41:
 602               		.cfi_def_cfa_offset 65
 603 0212 0FB6      		in __tmp_reg__,__SREG__
 604 0214 F894      		cli
 605 0216 DEBF      		out __SP_H__,r29
 606 0218 0FBE      		out __SREG__,__tmp_reg__
 607 021a CDBF      		out __SP_L__,r28
 608               	/* prologue: function */
 609               	/* frame size = 50 */
 610               	/* stack size = 62 */
 611               	.L__stack_usage = 62
 612 021c 5C01      		movw r10,r24
 613 021e 7B01      		movw r14,r22
 123:roomba.c      **** 	uint16_t start_value = getTicks();
 614               		.loc 1 123 0
 615 0220 0E94 0000 		call getTicks
 616               	.LVL56:
 617 0224 8C01      		movw r16,r24
 618               	.LVL57:
 125:roomba.c      **** 	drive(velocity);
 619               		.loc 1 125 0
 620 0226 C701      		movw r24,r14
 621 0228 0E94 0000 		call drive
 622               	.LVL58:
 128:roomba.c      **** 	sprintf(buff, "Ticks-Start: %u\r\n", start_value);
 623               		.loc 1 128 0
 624 022c 1F93      		push r17
 625 022e 0F93      		push r16
 626 0230 20E0      		ldi r18,lo8(.LC1)
 627 0232 30E0      		ldi r19,hi8(.LC1)
 628 0234 3F93      		push r19
 629 0236 2F93      		push r18
 630 0238 9E01      		movw r18,r28
 631 023a 2F5F      		subi r18,-1
 632 023c 3F4F      		sbci r19,-1
 633 023e 6901      		movw r12,r18
 634 0240 DF92      		push r13
 635 0242 2F93      		push r18
 636 0244 0E94 0000 		call sprintf
 637               	.LVL59:
 129:roomba.c      **** 	sendString(buff);
 638               		.loc 1 129 0
 639 0248 C601      		movw r24,r12
 640 024a 0E94 0000 		call sendString
 641               	.LVL60:
 131:roomba.c      **** 	uint16_t maxTicks = (uint16_t) (distance * 2.262);
 642               		.loc 1 131 0
 643 024e B501      		movw r22,r10
 644 0250 80E0      		ldi r24,0
 645 0252 90E0      		ldi r25,0
 646 0254 0E94 0000 		call __floatunsisf
 647               	.LVL61:
 648 0258 2CE9      		ldi r18,lo8(-100)
 649 025a 34EC      		ldi r19,lo8(-60)
 650 025c 40E1      		ldi r20,lo8(16)
 651 025e 50E4      		ldi r21,lo8(64)
 652 0260 0E94 0000 		call __mulsf3
 653               	.LVL62:
 654 0264 0E94 0000 		call __fixunssfsi
 655               	.LVL63:
 656 0268 A62E      		mov r10,r22
 657               	.LVL64:
 658 026a B72E      		mov r11,r23
 659               	.LVL65:
 132:roomba.c      **** 	sprintf(buff, "Max: %u\r\n", maxTicks);
 660               		.loc 1 132 0
 661 026c 7F93      		push r23
 662 026e 6F93      		push r22
 663 0270 80E0      		ldi r24,lo8(.LC4)
 664 0272 90E0      		ldi r25,hi8(.LC4)
 665               	.LVL66:
 666 0274 9F93      		push r25
 667 0276 8F93      		push r24
 668 0278 DF92      		push r13
 669 027a CF92      		push r12
 670 027c 0E94 0000 		call sprintf
 671               	.LVL67:
 133:roomba.c      **** 	sendString(buff);
 672               		.loc 1 133 0
 673 0280 C601      		movw r24,r12
 674 0282 0E94 0000 		call sendString
 675               	.LVL68:
 135:roomba.c      **** 	my_msleep(200);
 676               		.loc 1 135 0
 677 0286 88EC      		ldi r24,lo8(-56)
 678 0288 90E0      		ldi r25,0
 679 028a 0E94 0000 		call my_msleep
 680               	.LVL69:
 681 028e 0FB6      		in __tmp_reg__,__SREG__
 682 0290 F894      		cli
 683 0292 DEBF      		out __SP_H__,r29
 684 0294 0FBE      		out __SREG__,__tmp_reg__
 685 0296 CDBF      		out __SP_L__,r28
 686               	.LBB3:
 145:roomba.c      **** 			distanceTicks = start_value + (65535 - ticks);
 687               		.loc 1 145 0
 688 0298 4801      		movw r8,r16
 689 029a 91E0      		ldi r25,1
 690 029c 891A      		sub r8,r25
 691 029e 9108      		sbc r9,__zero_reg__
 143:roomba.c      **** 			distanceTicks = 65535 - start_value + ticks;
 692               		.loc 1 143 0
 693 02a0 6801      		movw r12,r16
 694 02a2 C094      		com r12
 695 02a4 D094      		com r13
 696               	.L21:
 138:roomba.c      **** 		uint16_t ticks = getTicks();
 697               		.loc 1 138 0
 698 02a6 0E94 0000 		call getTicks
 699               	.LVL70:
 142:roomba.c      **** 		if (ticks < start_value && velocity > 0) {
 700               		.loc 1 142 0
 701 02aa 8017      		cp r24,r16
 702 02ac 9107      		cpc r25,r17
 703 02ae 00F4      		brsh .L16
 142:roomba.c      **** 		if (ticks < start_value && velocity > 0) {
 704               		.loc 1 142 0 is_stmt 0 discriminator 1
 705 02b0 1E14      		cp __zero_reg__,r14
 706 02b2 1F04      		cpc __zero_reg__,r15
 707 02b4 04F4      		brge .L16
 143:roomba.c      **** 			distanceTicks = 65535 - start_value + ticks;
 708               		.loc 1 143 0 is_stmt 1
 709 02b6 8C0D      		add r24,r12
 710 02b8 9D1D      		adc r25,r13
 711               	.LVL71:
 712 02ba 00C0      		rjmp .L17
 713               	.LVL72:
 714               	.L16:
 144:roomba.c      **** 		} else if (ticks > start_value && velocity < 0) {
 715               		.loc 1 144 0
 716 02bc 0817      		cp r16,r24
 717 02be 1907      		cpc r17,r25
 718 02c0 00F4      		brsh .L18
 144:roomba.c      **** 		} else if (ticks > start_value && velocity < 0) {
 719               		.loc 1 144 0 is_stmt 0 discriminator 1
 720 02c2 FF20      		tst r15
 721 02c4 04F4      		brge .L18
 145:roomba.c      **** 			distanceTicks = start_value + (65535 - ticks);
 722               		.loc 1 145 0 is_stmt 1
 723 02c6 9401      		movw r18,r8
 724 02c8 281B      		sub r18,r24
 725 02ca 390B      		sbc r19,r25
 726 02cc C901      		movw r24,r18
 727               	.LVL73:
 728 02ce 00C0      		rjmp .L17
 729               	.LVL74:
 730               	.L18:
 147:roomba.c      **** 			distanceTicks = abs(ticks - start_value);
 731               		.loc 1 147 0
 732 02d0 9C01      		movw r18,r24
 733 02d2 201B      		sub r18,r16
 734 02d4 310B      		sbc r19,r17
 735 02d6 C901      		movw r24,r18
 736               	.LVL75:
 737 02d8 9923      		tst r25
 738 02da 04F4      		brge .L17
 739 02dc 8827      		clr r24
 740 02de 9927      		clr r25
 741 02e0 821B      		sub r24,r18
 742 02e2 930B      		sbc r25,r19
 743               	.LVL76:
 744               	.L17:
 150:roomba.c      **** 		if (distanceTicks > maxTicks) {
 745               		.loc 1 150 0
 746 02e4 A816      		cp r10,r24
 747 02e6 B906      		cpc r11,r25
 748 02e8 00F4      		brsh .L21
 749               	.LBE3:
 155:roomba.c      **** 	stop();
 750               		.loc 1 155 0
 751 02ea 0E94 0000 		call stop
 752               	.LVL77:
 753               	/* epilogue start */
 156:roomba.c      **** }
 754               		.loc 1 156 0
 755 02ee E296      		adiw r28,50
 756 02f0 0FB6      		in __tmp_reg__,__SREG__
 757 02f2 F894      		cli
 758 02f4 DEBF      		out __SP_H__,r29
 759 02f6 0FBE      		out __SREG__,__tmp_reg__
 760 02f8 CDBF      		out __SP_L__,r28
 761 02fa DF91      		pop r29
 762 02fc CF91      		pop r28
 763 02fe 1F91      		pop r17
 764 0300 0F91      		pop r16
 765               	.LVL78:
 766 0302 FF90      		pop r15
 767 0304 EF90      		pop r14
 768               	.LVL79:
 769 0306 DF90      		pop r13
 770 0308 CF90      		pop r12
 771               	.LVL80:
 772 030a BF90      		pop r11
 773 030c AF90      		pop r10
 774 030e 9F90      		pop r9
 775 0310 8F90      		pop r8
 776               	.LVL81:
 777 0312 0895      		ret
 778               		.cfi_endproc
 779               	.LFE8:
 781               	.global	receiveRemote
 783               	receiveRemote:
 784               	.LFB10:
 168:roomba.c      **** 
 169:roomba.c      **** /**
 170:roomba.c      ****  * \brief Receive a signal from the remote. Show the received
 171:roomba.c      ****  * 			value as hex on Display and drive corresponding
 172:roomba.c      ****  * 			to the steering buttons
 173:roomba.c      ****  */
 174:roomba.c      **** uint8_t receiveRemote() {
 785               		.loc 1 174 0
 786               		.cfi_startproc
 787 0314 CF93      		push r28
 788               	.LCFI42:
 789               		.cfi_def_cfa_offset 4
 790               		.cfi_offset 28, -3
 791 0316 DF93      		push r29
 792               	.LCFI43:
 793               		.cfi_def_cfa_offset 5
 794               		.cfi_offset 29, -4
 795 0318 1F92      		push __zero_reg__
 796 031a 1F92      		push __zero_reg__
 797               	.LCFI44:
 798               		.cfi_def_cfa_offset 7
 799 031c CDB7      		in r28,__SP_L__
 800 031e DEB7      		in r29,__SP_H__
 801               	.LCFI45:
 802               		.cfi_def_cfa_register 28
 803               	/* prologue: function */
 804               	/* frame size = 2 */
 805               	/* stack size = 4 */
 806               	.L__stack_usage = 4
 175:roomba.c      **** 	uint8_t data[2];
 176:roomba.c      **** 	read_values(17, data, 1);
 807               		.loc 1 176 0
 808 0320 41E0      		ldi r20,lo8(1)
 809 0322 BE01      		movw r22,r28
 810 0324 6F5F      		subi r22,-1
 811 0326 7F4F      		sbci r23,-1
 812 0328 81E1      		ldi r24,lo8(17)
 813 032a 0E94 0000 		call read_values
 814               	.LVL82:
 177:roomba.c      **** 	
 178:roomba.c      **** 	//showRemoteSignalInDisplay(data[0]);
 179:roomba.c      **** 	
 180:roomba.c      **** 	return data[0];
 181:roomba.c      **** }
 815               		.loc 1 181 0
 816 032e 8981      		ldd r24,Y+1
 817               	/* epilogue start */
 818 0330 0F90      		pop __tmp_reg__
 819 0332 0F90      		pop __tmp_reg__
 820 0334 DF91      		pop r29
 821 0336 CF91      		pop r28
 822 0338 0895      		ret
 823               		.cfi_endproc
 824               	.LFE10:
 826               		.section	.rodata.str1.1
 827               	.LC5:
 828 0038 2534 7800 		.string	"%4x"
 829               		.text
 830               	.global	intToHex
 832               	intToHex:
 833               	.LFB12:
 182:roomba.c      **** 
 183:roomba.c      **** /**
 184:roomba.c      ****  * \brief Show the pressed remote button hex code on display
 185:roomba.c      ****  * 
 186:roomba.c      ****  * \param data the received button code
 187:roomba.c      ****  */
 188:roomba.c      **** void showRemoteSignalInDisplay(char *data) {
 189:roomba.c      **** 	if (data == 0) {
 190:roomba.c      **** 		char empty[4] = {' ', ' ', ' ', ' '};
 191:roomba.c      **** 		set_Display(empty);
 192:roomba.c      **** 		
 193:roomba.c      **** 		return;
 194:roomba.c      **** 	}
 195:roomba.c      **** 	
 196:roomba.c      **** 	char result[4];
 197:roomba.c      **** 	intToHex((uint16_t) data, result);
 198:roomba.c      **** 	
 199:roomba.c      **** 	set_Display(result);
 200:roomba.c      **** }
 201:roomba.c      **** 
 202:roomba.c      **** /**
 203:roomba.c      ****  * \brief Convert a integer to a hex value
 204:roomba.c      ****  */
 205:roomba.c      **** void intToHex(uint16_t hex, char *result) {
 834               		.loc 1 205 0
 835               		.cfi_startproc
 836               	.LVL83:
 837               	/* prologue: function */
 838               	/* frame size = 0 */
 839               	/* stack size = 0 */
 840               	.L__stack_usage = 0
 206:roomba.c      **** 	sprintf(result, "%4x", hex);
 841               		.loc 1 206 0
 842 033a 9F93      		push r25
 843               	.LCFI46:
 844               		.cfi_def_cfa_offset 4
 845 033c 8F93      		push r24
 846               	.LCFI47:
 847               		.cfi_def_cfa_offset 5
 848 033e 80E0      		ldi r24,lo8(.LC5)
 849 0340 90E0      		ldi r25,hi8(.LC5)
 850               	.LVL84:
 851 0342 9F93      		push r25
 852               	.LCFI48:
 853               		.cfi_def_cfa_offset 6
 854 0344 8F93      		push r24
 855               	.LCFI49:
 856               		.cfi_def_cfa_offset 7
 857 0346 7F93      		push r23
 858               	.LCFI50:
 859               		.cfi_def_cfa_offset 8
 860 0348 6F93      		push r22
 861               	.LCFI51:
 862               		.cfi_def_cfa_offset 9
 863 034a 0E94 0000 		call sprintf
 864               	.LVL85:
 865 034e 0F90      		pop __tmp_reg__
 866 0350 0F90      		pop __tmp_reg__
 867 0352 0F90      		pop __tmp_reg__
 868 0354 0F90      		pop __tmp_reg__
 869 0356 0F90      		pop __tmp_reg__
 870 0358 0F90      		pop __tmp_reg__
 871               	.LCFI52:
 872               		.cfi_def_cfa_offset 3
 873 035a 0895      		ret
 874               		.cfi_endproc
 875               	.LFE12:
 877               	.global	showRemoteSignalInDisplay
 879               	showRemoteSignalInDisplay:
 880               	.LFB11:
 188:roomba.c      **** void showRemoteSignalInDisplay(char *data) {
 881               		.loc 1 188 0
 882               		.cfi_startproc
 883               	.LVL86:
 884 035c CF93      		push r28
 885               	.LCFI53:
 886               		.cfi_def_cfa_offset 4
 887               		.cfi_offset 28, -3
 888 035e DF93      		push r29
 889               	.LCFI54:
 890               		.cfi_def_cfa_offset 5
 891               		.cfi_offset 29, -4
 892 0360 CDB7      		in r28,__SP_L__
 893 0362 DEB7      		in r29,__SP_H__
 894               	.LCFI55:
 895               		.cfi_def_cfa_register 28
 896 0364 2897      		sbiw r28,8
 897               	.LCFI56:
 898               		.cfi_def_cfa_offset 13
 899 0366 0FB6      		in __tmp_reg__,__SREG__
 900 0368 F894      		cli
 901 036a DEBF      		out __SP_H__,r29
 902 036c 0FBE      		out __SREG__,__tmp_reg__
 903 036e CDBF      		out __SP_L__,r28
 904               	/* prologue: function */
 905               	/* frame size = 8 */
 906               	/* stack size = 10 */
 907               	.L__stack_usage = 10
 189:roomba.c      **** 	if (data == 0) {
 908               		.loc 1 189 0
 909 0370 0097      		sbiw r24,0
 910 0372 01F4      		brne .L25
 911               	.LBB4:
 190:roomba.c      **** 		char empty[4] = {' ', ' ', ' ', ' '};
 912               		.loc 1 190 0
 913 0374 80E2      		ldi r24,lo8(32)
 914               	.LVL87:
 915 0376 8D83      		std Y+5,r24
 916 0378 8E83      		std Y+6,r24
 917 037a 8F83      		std Y+7,r24
 918 037c 8887      		std Y+8,r24
 191:roomba.c      **** 		set_Display(empty);
 919               		.loc 1 191 0
 920 037e CE01      		movw r24,r28
 921 0380 0596      		adiw r24,5
 922 0382 0E94 0000 		call set_Display
 923               	.LVL88:
 924 0386 00C0      		rjmp .L24
 925               	.LVL89:
 926               	.L25:
 927               	.LBE4:
 197:roomba.c      **** 	intToHex((uint16_t) data, result);
 928               		.loc 1 197 0
 929 0388 BE01      		movw r22,r28
 930 038a 6F5F      		subi r22,-1
 931 038c 7F4F      		sbci r23,-1
 932 038e 0E94 0000 		call intToHex
 933               	.LVL90:
 199:roomba.c      **** 	set_Display(result);
 934               		.loc 1 199 0
 935 0392 CE01      		movw r24,r28
 936 0394 0196      		adiw r24,1
 937 0396 0E94 0000 		call set_Display
 938               	.LVL91:
 939               	.L24:
 940               	/* epilogue start */
 200:roomba.c      **** }
 941               		.loc 1 200 0
 942 039a 2896      		adiw r28,8
 943 039c 0FB6      		in __tmp_reg__,__SREG__
 944 039e F894      		cli
 945 03a0 DEBF      		out __SP_H__,r29
 946 03a2 0FBE      		out __SREG__,__tmp_reg__
 947 03a4 CDBF      		out __SP_L__,r28
 948 03a6 DF91      		pop r29
 949 03a8 CF91      		pop r28
 950 03aa 0895      		ret
 951               		.cfi_endproc
 952               	.LFE11:
 954               	.global	driveWithRadius
 956               	driveWithRadius:
 957               	.LFB13:
 207:roomba.c      **** }
 208:roomba.c      **** 
 209:roomba.c      **** /**
 210:roomba.c      ****  * \brief Drive roomba with
 211:roomba.c      ****  * 
 212:roomba.c      ****  * \param velocity this velocity
 213:roomba.c      ****  * \param radius this radius (use DRIVE_STRAIGHT for straight, -1 for 
 214:roomba.c      ****  * 			clockwise 1 for anticlockwise)
 215:roomba.c      ****  */
 216:roomba.c      **** void driveWithRadius(uint16_t velocity, uint16_t radius) {
 958               		.loc 1 216 0
 959               		.cfi_startproc
 960               	.LVL92:
 961 03ac 0F93      		push r16
 962               	.LCFI57:
 963               		.cfi_def_cfa_offset 4
 964               		.cfi_offset 16, -3
 965 03ae 1F93      		push r17
 966               	.LCFI58:
 967               		.cfi_def_cfa_offset 5
 968               		.cfi_offset 17, -4
 969 03b0 CF93      		push r28
 970               	.LCFI59:
 971               		.cfi_def_cfa_offset 6
 972               		.cfi_offset 28, -5
 973 03b2 DF93      		push r29
 974               	.LCFI60:
 975               		.cfi_def_cfa_offset 7
 976               		.cfi_offset 29, -6
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 4 */
 980               	.L__stack_usage = 4
 981 03b4 182F      		mov r17,r24
 982 03b6 092F      		mov r16,r25
 983 03b8 C62F      		mov r28,r22
 984 03ba D72F      		mov r29,r23
 217:roomba.c      **** 	send_byte_roomba(137);
 985               		.loc 1 217 0
 986 03bc 89E8      		ldi r24,lo8(-119)
 987               	.LVL93:
 988 03be 0E94 0000 		call send_byte_roomba
 989               	.LVL94:
 218:roomba.c      **** 	
 219:roomba.c      **** 	uint8_t low = velocity;
 220:roomba.c      **** 	uint8_t high = (velocity >> 8);
 221:roomba.c      **** 	
 222:roomba.c      **** 	send_byte_roomba(high);
 990               		.loc 1 222 0
 991 03c2 802F      		mov r24,r16
 992 03c4 0E94 0000 		call send_byte_roomba
 993               	.LVL95:
 223:roomba.c      **** 	send_byte_roomba(low);	
 994               		.loc 1 223 0
 995 03c8 812F      		mov r24,r17
 996 03ca 0E94 0000 		call send_byte_roomba
 997               	.LVL96:
 224:roomba.c      **** 	
 225:roomba.c      **** 	uint8_t rlow = radius;
 226:roomba.c      **** 	uint8_t rhigh = (radius >> 8);
 227:roomba.c      **** 	
 228:roomba.c      **** 	send_byte_roomba(rhigh);
 998               		.loc 1 228 0
 999 03ce 8D2F      		mov r24,r29
 1000 03d0 0E94 0000 		call send_byte_roomba
 1001               	.LVL97:
 229:roomba.c      **** 	send_byte_roomba(rlow);	
 1002               		.loc 1 229 0
 1003 03d4 8C2F      		mov r24,r28
 1004 03d6 0E94 0000 		call send_byte_roomba
 1005               	.LVL98:
 1006               	/* epilogue start */
 230:roomba.c      **** }
 1007               		.loc 1 230 0
 1008 03da DF91      		pop r29
 1009               	.LVL99:
 1010 03dc CF91      		pop r28
 1011               	.LVL100:
 1012 03de 1F91      		pop r17
 1013               	.LVL101:
 1014 03e0 0F91      		pop r16
 1015               	.LVL102:
 1016 03e2 0895      		ret
 1017               		.cfi_endproc
 1018               	.LFE13:
 1020               		.section	.rodata
 1021               	.LC0:
 1022 0000 6300      		.word	99
 1023 0002 6300      		.word	99
 1024 0004 6300      		.word	99
 1025 0006 6300      		.word	99
 1026               		.text
 1027               	.global	read_user_input
 1029               	read_user_input:
 1030               	.LFB14:
 231:roomba.c      **** 
 232:roomba.c      **** /**
 233:roomba.c      ****  * \brief Read 4 numbers from remote control
 234:roomba.c      ****  * 
 235:roomba.c      ****  * \return the entered number
 236:roomba.c      ****  */
 237:roomba.c      **** uint16_t read_user_input() {
 1031               		.loc 1 237 0
 1032               		.cfi_startproc
 1033 03e4 8F92      		push r8
 1034               	.LCFI61:
 1035               		.cfi_def_cfa_offset 4
 1036               		.cfi_offset 8, -3
 1037 03e6 9F92      		push r9
 1038               	.LCFI62:
 1039               		.cfi_def_cfa_offset 5
 1040               		.cfi_offset 9, -4
 1041 03e8 AF92      		push r10
 1042               	.LCFI63:
 1043               		.cfi_def_cfa_offset 6
 1044               		.cfi_offset 10, -5
 1045 03ea BF92      		push r11
 1046               	.LCFI64:
 1047               		.cfi_def_cfa_offset 7
 1048               		.cfi_offset 11, -6
 1049 03ec CF92      		push r12
 1050               	.LCFI65:
 1051               		.cfi_def_cfa_offset 8
 1052               		.cfi_offset 12, -7
 1053 03ee DF92      		push r13
 1054               	.LCFI66:
 1055               		.cfi_def_cfa_offset 9
 1056               		.cfi_offset 13, -8
 1057 03f0 EF92      		push r14
 1058               	.LCFI67:
 1059               		.cfi_def_cfa_offset 10
 1060               		.cfi_offset 14, -9
 1061 03f2 FF92      		push r15
 1062               	.LCFI68:
 1063               		.cfi_def_cfa_offset 11
 1064               		.cfi_offset 15, -10
 1065 03f4 0F93      		push r16
 1066               	.LCFI69:
 1067               		.cfi_def_cfa_offset 12
 1068               		.cfi_offset 16, -11
 1069 03f6 1F93      		push r17
 1070               	.LCFI70:
 1071               		.cfi_def_cfa_offset 13
 1072               		.cfi_offset 17, -12
 1073 03f8 CF93      		push r28
 1074               	.LCFI71:
 1075               		.cfi_def_cfa_offset 14
 1076               		.cfi_offset 28, -13
 1077 03fa DF93      		push r29
 1078               	.LCFI72:
 1079               		.cfi_def_cfa_offset 15
 1080               		.cfi_offset 29, -14
 1081 03fc CDB7      		in r28,__SP_L__
 1082 03fe DEB7      		in r29,__SP_H__
 1083               	.LCFI73:
 1084               		.cfi_def_cfa_register 28
 1085 0400 6097      		sbiw r28,16
 1086               	.LCFI74:
 1087               		.cfi_def_cfa_offset 31
 1088 0402 0FB6      		in __tmp_reg__,__SREG__
 1089 0404 F894      		cli
 1090 0406 DEBF      		out __SP_H__,r29
 1091 0408 0FBE      		out __SREG__,__tmp_reg__
 1092 040a CDBF      		out __SP_L__,r28
 1093               	/* prologue: function */
 1094               	/* frame size = 16 */
 1095               	/* stack size = 28 */
 1096               	.L__stack_usage = 28
 238:roomba.c      **** 	char awaitInput[4] = {'-', '-', '-', '-'};
 1097               		.loc 1 238 0
 1098 040c 1DE2      		ldi r17,lo8(45)
 1099 040e 1983      		std Y+1,r17
 1100 0410 1A83      		std Y+2,r17
 1101 0412 1B83      		std Y+3,r17
 1102 0414 1C83      		std Y+4,r17
 239:roomba.c      **** 	set_Display(awaitInput);
 1103               		.loc 1 239 0
 1104 0416 CE01      		movw r24,r28
 1105 0418 0196      		adiw r24,1
 1106 041a 0E94 0000 		call set_Display
 1107               	.LVL103:
 240:roomba.c      **** 	
 241:roomba.c      **** 	// Set 99 as dummy value (we can't have bigger numbers than 9)
 242:roomba.c      **** 	uint16_t remoteVal[4] = {99, 99, 99, 99};
 1108               		.loc 1 242 0
 1109 041e 88E0      		ldi r24,lo8(8)
 1110 0420 E0E0      		ldi r30,lo8(.LC0)
 1111 0422 F0E0      		ldi r31,hi8(.LC0)
 1112 0424 DE01      		movw r26,r28
 1113 0426 1596      		adiw r26,5
 1114               		0:
 1115 0428 0190      		ld r0,Z+
 1116 042a 0D92      		st X+,r0
 1117 042c 8A95      		dec r24
 1118 042e 01F4      		brne 0b
 1119               	.LVL104:
 1120               	.LBB5:
 243:roomba.c      **** 	
 244:roomba.c      **** 	// Holds display chars
 245:roomba.c      **** 	char toDisplay[4];
 246:roomba.c      **** 	
 247:roomba.c      **** 	// The actual received value from the remote
 248:roomba.c      **** 	uint8_t actVal;
 249:roomba.c      **** 	
 250:roomba.c      **** 	// Set display to - - - -
 251:roomba.c      **** 	for (uint8_t b = 0; b < 4; b++) {
 252:roomba.c      **** 		toDisplay[b] = '-';	
 1121               		.loc 1 252 0
 1122 0430 1D87      		std Y+13,r17
 1123               	.LVL105:
 1124 0432 1E87      		std Y+14,r17
 1125               	.LVL106:
 1126 0434 1F87      		std Y+15,r17
 1127               	.LVL107:
 1128 0436 188B      		std Y+16,r17
 1129               	.LVL108:
 1130 0438 7E01      		movw r14,r28
 1131 043a 25E0      		ldi r18,5
 1132 043c E20E      		add r14,r18
 1133 043e F11C      		adc r15,__zero_reg__
 1134 0440 00E0      		ldi r16,0
 1135 0442 10E0      		ldi r17,0
 1136 0444 5E01      		movw r10,r28
 1137 0446 3DE0      		ldi r19,13
 1138 0448 A30E      		add r10,r19
 1139 044a B11C      		adc r11,__zero_reg__
 1140 044c 8A2C      		mov r8,r10
 1141 044e 9B2C      		mov r9,r11
 1142 0450 00C0      		rjmp .L29
 1143               	.LVL109:
 1144               	.L34:
 1145               	.LBE5:
 1146               	.LBB6:
 253:roomba.c      **** 	}
 254:roomba.c      **** 	
 255:roomba.c      **** 	// 0 is 0x81 = 129
 256:roomba.c      **** 	uint8_t finished = 0;
 257:roomba.c      **** 	uint16_t counter = 0;
 258:roomba.c      **** 	while (counter < 4 && finished == 0) {
 259:roomba.c      **** 		uint8_t flag = 1;
 260:roomba.c      **** 
 261:roomba.c      **** 		while(flag) {
 262:roomba.c      **** 			actVal = receiveRemote();
 1147               		.loc 1 262 0
 1148 0452 0E94 0000 		call receiveRemote
 1149               	.LVL110:
 263:roomba.c      **** 			
 264:roomba.c      **** 			if (actVal != 0) {
 1150               		.loc 1 264 0
 1151 0456 8823      		tst r24
 1152 0458 01F0      		breq .L34
 265:roomba.c      **** 				// Check if arrow to right
 266:roomba.c      **** 				if (actVal == REMOTE_RIGHT && remoteVal[counter] != 99) {
 1153               		.loc 1 266 0
 1154 045a 8F38      		cpi r24,lo8(-113)
 1155 045c 01F4      		brne .L31
 1156               		.loc 1 266 0 is_stmt 0 discriminator 1
 1157 045e F701      		movw r30,r14
 1158 0460 2081      		ld r18,Z
 1159 0462 3181      		ldd r19,Z+1
 1160 0464 2336      		cpi r18,99
 1161 0466 3105      		cpc r19,__zero_reg__
 1162 0468 01F0      		breq .L34
 1163               	.LVL111:
 267:roomba.c      **** 					flag = 0;
 268:roomba.c      **** 					counter++;
 1164               		.loc 1 268 0 is_stmt 1
 1165 046a 0F5F      		subi r16,-1
 1166 046c 1F4F      		sbci r17,-1
 1167               	.LVL112:
 1168 046e F2E0      		ldi r31,2
 1169 0470 EF0E      		add r14,r31
 1170 0472 F11C      		adc r15,__zero_reg__
 1171               	.LBE6:
 258:roomba.c      **** 	while (counter < 4 && finished == 0) {
 1172               		.loc 1 258 0
 1173 0474 0430      		cpi r16,4
 1174 0476 1105      		cpc r17,__zero_reg__
 1175 0478 01F4      		brne .L29
 1176 047a 00C0      		rjmp .L32
 1177               	.LVL113:
 1178               	.L31:
 1179               	.LBB7:
 269:roomba.c      **** 				} 
 270:roomba.c      **** 				// Input finished
 271:roomba.c      **** 				else if (actVal == REMOTE_POWER && counter > 0) {
 1180               		.loc 1 271 0
 1181 047c 8A38      		cpi r24,lo8(-118)
 1182 047e 01F4      		brne .L33
 1183               		.loc 1 271 0 is_stmt 0 discriminator 1
 1184 0480 0115      		cp r16,__zero_reg__
 1185 0482 1105      		cpc r17,__zero_reg__
 1186 0484 01F0      		breq .L34
 1187 0486 00C0      		rjmp .L32
 1188               	.L33:
 272:roomba.c      **** 					finished = 1;
 273:roomba.c      **** 					break;
 274:roomba.c      **** 				}
 275:roomba.c      **** 				// Check if it is really a number
 276:roomba.c      **** 				else if (actVal != REMOTE_RIGHT && actVal != REMOTE_POWER && actVal >= ROOMBA_0 && actVal <= (R
 1189               		.loc 1 276 0 is_stmt 1 discriminator 1
 1190 0488 9FE7      		ldi r25,lo8(127)
 1191 048a 980F      		add r25,r24
 1192 048c 9A30      		cpi r25,lo8(10)
 1193 048e 00F4      		brsh .L34
 277:roomba.c      **** 					remoteVal[counter] = actVal - ROOMBA_0;
 1194               		.loc 1 277 0
 1195 0490 282F      		mov r18,r24
 1196 0492 30E0      		ldi r19,0
 1197 0494 2158      		subi r18,-127
 1198 0496 3109      		sbc r19,__zero_reg__
 1199 0498 F701      		movw r30,r14
 1200 049a 3183      		std Z+1,r19
 1201 049c 2083      		st Z,r18
 278:roomba.c      **** 					toDisplay[counter] = (remoteVal[counter] + ASCI_0);
 1202               		.loc 1 278 0
 1203 049e 205D      		subi r18,lo8(-(48))
 1204 04a0 F601      		movw r30,r12
 1205 04a2 2083      		st Z,r18
 279:roomba.c      **** 					
 280:roomba.c      **** 					set_Display(toDisplay);
 1206               		.loc 1 280 0
 1207 04a4 882D      		mov r24,r8
 1208               	.LVL114:
 1209 04a6 992D      		mov r25,r9
 1210 04a8 0E94 0000 		call set_Display
 1211               	.LVL115:
 1212 04ac 00C0      		rjmp .L34
 1213               	.LVL116:
 1214               	.L29:
 1215 04ae 6501      		movw r12,r10
 1216 04b0 C00E      		add r12,r16
 1217 04b2 D11E      		adc r13,r17
 1218 04b4 00C0      		rjmp .L34
 1219               	.LVL117:
 1220               	.L36:
 1221               	.LBE7:
 1222               	.LBB8:
 281:roomba.c      **** 				}
 282:roomba.c      **** 			}			
 283:roomba.c      **** 		}
 284:roomba.c      **** 	}
 285:roomba.c      **** 	
 286:roomba.c      **** 	// Calculate number
 287:roomba.c      **** 	uint16_t result = 0;
 288:roomba.c      **** 	
 289:roomba.c      **** 	for (uint8_t b = 0; b < counter; b++) {
 290:roomba.c      **** 		result = result * 10;
 1223               		.loc 1 290 0 discriminator 2
 1224 04b6 9C01      		movw r18,r24
 1225 04b8 220F      		lsl r18
 1226 04ba 331F      		rol r19
 1227 04bc 880F      		lsl r24
 1228 04be 991F      		rol r25
 1229 04c0 880F      		lsl r24
 1230 04c2 991F      		rol r25
 1231 04c4 880F      		lsl r24
 1232 04c6 991F      		rol r25
 1233               	.LVL118:
 1234 04c8 820F      		add r24,r18
 1235 04ca 931F      		adc r25,r19
 1236               	.LVL119:
 291:roomba.c      **** 		result = result + remoteVal[b];
 1237               		.loc 1 291 0 discriminator 2
 1238 04cc E42F      		mov r30,r20
 1239 04ce F0E0      		ldi r31,0
 1240 04d0 EE0F      		lsl r30
 1241 04d2 FF1F      		rol r31
 1242 04d4 21E0      		ldi r18,lo8(1)
 1243 04d6 30E0      		ldi r19,0
 1244 04d8 2C0F      		add r18,r28
 1245 04da 3D1F      		adc r19,r29
 1246 04dc E20F      		add r30,r18
 1247 04de F31F      		adc r31,r19
 1248 04e0 2481      		ldd r18,Z+4
 1249 04e2 3581      		ldd r19,Z+5
 1250 04e4 820F      		add r24,r18
 1251 04e6 931F      		adc r25,r19
 1252               	.LVL120:
 289:roomba.c      **** 	for (uint8_t b = 0; b < counter; b++) {
 1253               		.loc 1 289 0 discriminator 2
 1254 04e8 4F5F      		subi r20,lo8(-(1))
 1255               	.LVL121:
 1256 04ea 242F      		mov r18,r20
 1257 04ec 30E0      		ldi r19,0
 1258 04ee 2017      		cp r18,r16
 1259 04f0 3107      		cpc r19,r17
 1260 04f2 00F0      		brlo .L36
 1261 04f4 00C0      		rjmp .L37
 1262               	.LVL122:
 1263               	.L32:
 1264               	.LBE8:
 1265               	.LBB9:
 252:roomba.c      **** 		toDisplay[b] = '-';	
 1266               		.loc 1 252 0
 1267 04f6 40E0      		ldi r20,0
 1268 04f8 80E0      		ldi r24,0
 1269 04fa 90E0      		ldi r25,0
 1270               	.LVL123:
 1271 04fc 00C0      		rjmp .L36
 1272               	.LVL124:
 1273               	.L37:
 1274               	/* epilogue start */
 1275               	.LBE9:
 292:roomba.c      **** 	}
 293:roomba.c      **** 	
 294:roomba.c      **** 	
 295:roomba.c      **** 	return result;
 296:roomba.c      **** }
 1276               		.loc 1 296 0
 1277 04fe 6096      		adiw r28,16
 1278 0500 0FB6      		in __tmp_reg__,__SREG__
 1279 0502 F894      		cli
 1280 0504 DEBF      		out __SP_H__,r29
 1281 0506 0FBE      		out __SREG__,__tmp_reg__
 1282 0508 CDBF      		out __SP_L__,r28
 1283 050a DF91      		pop r29
 1284 050c CF91      		pop r28
 1285 050e 1F91      		pop r17
 1286 0510 0F91      		pop r16
 1287               	.LVL125:
 1288 0512 FF90      		pop r15
 1289 0514 EF90      		pop r14
 1290 0516 DF90      		pop r13
 1291 0518 CF90      		pop r12
 1292 051a BF90      		pop r11
 1293 051c AF90      		pop r10
 1294 051e 9F90      		pop r9
 1295 0520 8F90      		pop r8
 1296 0522 0895      		ret
 1297               		.cfi_endproc
 1298               	.LFE14:
 1300               	.global	drive_circle
 1302               	drive_circle:
 1303               	.LFB15:
 297:roomba.c      **** 
 298:roomba.c      **** /**
 299:roomba.c      ****  * \brief Drive a circle 
 300:roomba.c      ****  * 
 301:roomba.c      ****  * \param radius the radius to drive (with bigger radiuses it gets much bigger)
 302:roomba.c      ****  * \param velocity
 303:roomba.c      ****  */
 304:roomba.c      **** void drive_circle(uint16_t radius, uint16_t velocity) {
 1304               		.loc 1 304 0
 1305               		.cfi_startproc
 1306               	.LVL126:
 1307               	/* prologue: function */
 1308               	/* frame size = 0 */
 1309               	/* stack size = 0 */
 1310               	.L__stack_usage = 0
 1311 0524 9C01      		movw r18,r24
 1312 0526 CB01      		movw r24,r22
 1313               	.LVL127:
 305:roomba.c      **** 	driveWithRadius(velocity, radius);
 1314               		.loc 1 305 0
 1315 0528 B901      		movw r22,r18
 1316               	.LVL128:
 1317 052a 0E94 0000 		call driveWithRadius
 1318               	.LVL129:
 1319 052e 0895      		ret
 1320               		.cfi_endproc
 1321               	.LFE15:
 1323               	.global	turn
 1325               	turn:
 1326               	.LFB16:
 306:roomba.c      **** }
 307:roomba.c      **** 
 308:roomba.c      **** /**
 309:roomba.c      ****  * \brief Turn the robot by
 310:roomba.c      ****  * 
 311:roomba.c      ****  * \param degree 
 312:roomba.c      ****  */
 313:roomba.c      **** void turn(int16_t degree) {
 1327               		.loc 1 313 0
 1328               		.cfi_startproc
 1329               	.LVL130:
 1330 0530 CF93      		push r28
 1331               	.LCFI75:
 1332               		.cfi_def_cfa_offset 4
 1333               		.cfi_offset 28, -3
 1334 0532 DF93      		push r29
 1335               	.LCFI76:
 1336               		.cfi_def_cfa_offset 5
 1337               		.cfi_offset 29, -4
 1338               	/* prologue: function */
 1339               	/* frame size = 0 */
 1340               	/* stack size = 2 */
 1341               	.L__stack_usage = 2
 314:roomba.c      **** 	// In 13 seconds, 360
 315:roomba.c      **** 	uint16_t delay = (13000 / 360) * abs(degree);
 1342               		.loc 1 315 0
 1343 0534 9C01      		movw r18,r24
 1344 0536 9923      		tst r25
 1345 0538 04F4      		brge .L40
 1346 053a 2227      		clr r18
 1347 053c 3327      		clr r19
 1348 053e 281B      		sub r18,r24
 1349 0540 390B      		sbc r19,r25
 1350               	.L40:
 1351 0542 44E2      		ldi r20,lo8(36)
 1352 0544 429F      		mul r20,r18
 1353 0546 E001      		movw r28,r0
 1354 0548 439F      		mul r20,r19
 1355 054a D00D      		add r29,r0
 1356 054c 1124      		clr __zero_reg__
 1357               	.LVL131:
 316:roomba.c      **** 	
 317:roomba.c      **** 	if (degree > 0) {
 1358               		.loc 1 317 0
 1359 054e 1816      		cp __zero_reg__,r24
 1360 0550 1906      		cpc __zero_reg__,r25
 1361 0552 04F4      		brge .L41
 318:roomba.c      **** 		driveWithRadius(50, 1);
 1362               		.loc 1 318 0
 1363 0554 61E0      		ldi r22,lo8(1)
 1364 0556 70E0      		ldi r23,0
 1365 0558 82E3      		ldi r24,lo8(50)
 1366 055a 90E0      		ldi r25,0
 1367               	.LVL132:
 1368 055c 0E94 0000 		call driveWithRadius
 1369               	.LVL133:
 1370 0560 00C0      		rjmp .L42
 1371               	.LVL134:
 1372               	.L41:
 319:roomba.c      **** 	} else {
 320:roomba.c      **** 		driveWithRadius(50, -1);
 1373               		.loc 1 320 0
 1374 0562 6FEF      		ldi r22,lo8(-1)
 1375 0564 7FEF      		ldi r23,lo8(-1)
 1376 0566 82E3      		ldi r24,lo8(50)
 1377 0568 90E0      		ldi r25,0
 1378               	.LVL135:
 1379 056a 0E94 0000 		call driveWithRadius
 1380               	.LVL136:
 1381               	.L42:
 321:roomba.c      **** 	}
 322:roomba.c      **** 	
 323:roomba.c      **** 	my_msleep(delay);
 1382               		.loc 1 323 0
 1383 056e CE01      		movw r24,r28
 1384 0570 0E94 0000 		call my_msleep
 1385               	.LVL137:
 324:roomba.c      **** 	
 325:roomba.c      **** 	driveWithRadius(0, 0);
 1386               		.loc 1 325 0
 1387 0574 60E0      		ldi r22,0
 1388 0576 70E0      		ldi r23,0
 1389 0578 80E0      		ldi r24,0
 1390 057a 90E0      		ldi r25,0
 1391 057c 0E94 0000 		call driveWithRadius
 1392               	.LVL138:
 1393               	/* epilogue start */
 326:roomba.c      **** }
 1394               		.loc 1 326 0
 1395 0580 DF91      		pop r29
 1396 0582 CF91      		pop r28
 1397               	.LVL139:
 1398 0584 0895      		ret
 1399               		.cfi_endproc
 1400               	.LFE16:
 1402               	.global	set_back
 1404               	set_back:
 1405               	.LFB19:
 327:roomba.c      **** 
 328:roomba.c      **** /**
 329:roomba.c      ****  * \brief drive straight, till a bumper sensor is active,
 330:roomba.c      ****  * 		set-back and turn
 331:roomba.c      ****  */
 332:roomba.c      **** void drive_autonom() {
 333:roomba.c      **** 	while (1) {
 334:roomba.c      **** 		drive(150);
 335:roomba.c      **** 		
 336:roomba.c      **** 		// Bumpers
 337:roomba.c      **** 		uint8_t data[2];
 338:roomba.c      **** 		read_values(7, data, 1);
 339:roomba.c      **** 			
 340:roomba.c      **** 		bump_handling(data[0]);
 341:roomba.c      **** 	}
 342:roomba.c      **** }
 343:roomba.c      **** 
 344:roomba.c      **** /**
 345:roomba.c      ****  * \brief Set back and turn, if a bump is registered
 346:roomba.c      ****  * 
 347:roomba.c      ****  * \param bump the byte where the bump values are stored
 348:roomba.c      ****  */
 349:roomba.c      **** void bump_handling(uint8_t bump) {
 350:roomba.c      **** 	if ((bump & 0x02) == 0x02) {
 351:roomba.c      **** 		// Left bumper
 352:roomba.c      **** 		set_back();
 353:roomba.c      **** 		turn(-80);
 354:roomba.c      **** 	} else if ((bump & 0x01) == 0x01) {
 355:roomba.c      **** 		// Right bumper
 356:roomba.c      **** 		set_back();
 357:roomba.c      **** 		turn(45);
 358:roomba.c      **** 	} 
 359:roomba.c      **** }
 360:roomba.c      **** 
 361:roomba.c      **** /**
 362:roomba.c      ****  * \brief Drive a bit backwards
 363:roomba.c      ****  */
 364:roomba.c      **** void set_back() {
 1406               		.loc 1 364 0
 1407               		.cfi_startproc
 1408               	/* prologue: function */
 1409               	/* frame size = 0 */
 1410               	/* stack size = 0 */
 1411               	.L__stack_usage = 0
 365:roomba.c      **** 	drive(-100);
 1412               		.loc 1 365 0
 1413 0586 8CE9      		ldi r24,lo8(-100)
 1414 0588 9FEF      		ldi r25,lo8(-1)
 1415 058a 0E94 0000 		call drive
 1416               	.LVL140:
 366:roomba.c      **** 	my_msleep(1700);
 1417               		.loc 1 366 0
 1418 058e 84EA      		ldi r24,lo8(-92)
 1419 0590 96E0      		ldi r25,lo8(6)
 1420 0592 0E94 0000 		call my_msleep
 1421               	.LVL141:
 367:roomba.c      **** 	drive(0);
 1422               		.loc 1 367 0
 1423 0596 80E0      		ldi r24,0
 1424 0598 90E0      		ldi r25,0
 1425 059a 0E94 0000 		call drive
 1426               	.LVL142:
 1427 059e 0895      		ret
 1428               		.cfi_endproc
 1429               	.LFE19:
 1431               	.global	bump_handling
 1433               	bump_handling:
 1434               	.LFB18:
 349:roomba.c      **** void bump_handling(uint8_t bump) {
 1435               		.loc 1 349 0
 1436               		.cfi_startproc
 1437               	.LVL143:
 1438               	/* prologue: function */
 1439               	/* frame size = 0 */
 1440               	/* stack size = 0 */
 1441               	.L__stack_usage = 0
 350:roomba.c      **** 	if ((bump & 0x02) == 0x02) {
 1442               		.loc 1 350 0
 1443 05a0 81FF      		sbrs r24,1
 1444 05a2 00C0      		rjmp .L45
 352:roomba.c      **** 		set_back();
 1445               		.loc 1 352 0
 1446 05a4 0E94 0000 		call set_back
 1447               	.LVL144:
 353:roomba.c      **** 		turn(-80);
 1448               		.loc 1 353 0
 1449 05a8 80EB      		ldi r24,lo8(-80)
 1450 05aa 9FEF      		ldi r25,lo8(-1)
 1451 05ac 0E94 0000 		call turn
 1452               	.LVL145:
 1453 05b0 0895      		ret
 1454               	.LVL146:
 1455               	.L45:
 354:roomba.c      **** 	} else if ((bump & 0x01) == 0x01) {
 1456               		.loc 1 354 0
 1457 05b2 80FF      		sbrs r24,0
 1458 05b4 00C0      		rjmp .L44
 356:roomba.c      **** 		set_back();
 1459               		.loc 1 356 0
 1460 05b6 0E94 0000 		call set_back
 1461               	.LVL147:
 357:roomba.c      **** 		turn(45);
 1462               		.loc 1 357 0
 1463 05ba 8DE2      		ldi r24,lo8(45)
 1464 05bc 90E0      		ldi r25,0
 1465 05be 0E94 0000 		call turn
 1466               	.LVL148:
 1467               	.L44:
 1468 05c2 0895      		ret
 1469               		.cfi_endproc
 1470               	.LFE18:
 1472               	.global	drive_autonom
 1474               	drive_autonom:
 1475               	.LFB17:
 332:roomba.c      **** void drive_autonom() {
 1476               		.loc 1 332 0
 1477               		.cfi_startproc
 1478 05c4 CF93      		push r28
 1479               	.LCFI77:
 1480               		.cfi_def_cfa_offset 4
 1481               		.cfi_offset 28, -3
 1482 05c6 DF93      		push r29
 1483               	.LCFI78:
 1484               		.cfi_def_cfa_offset 5
 1485               		.cfi_offset 29, -4
 1486 05c8 1F92      		push __zero_reg__
 1487 05ca 1F92      		push __zero_reg__
 1488               	.LCFI79:
 1489               		.cfi_def_cfa_offset 7
 1490 05cc CDB7      		in r28,__SP_L__
 1491 05ce DEB7      		in r29,__SP_H__
 1492               	.LCFI80:
 1493               		.cfi_def_cfa_register 28
 1494               	/* prologue: function */
 1495               	/* frame size = 2 */
 1496               	/* stack size = 4 */
 1497               	.L__stack_usage = 4
 1498               	.L48:
 1499               	.LBB10:
 334:roomba.c      **** 		drive(150);
 1500               		.loc 1 334 0 discriminator 1
 1501 05d0 86E9      		ldi r24,lo8(-106)
 1502 05d2 90E0      		ldi r25,0
 1503 05d4 0E94 0000 		call drive
 1504               	.LVL149:
 338:roomba.c      **** 		read_values(7, data, 1);
 1505               		.loc 1 338 0 discriminator 1
 1506 05d8 41E0      		ldi r20,lo8(1)
 1507 05da BE01      		movw r22,r28
 1508 05dc 6F5F      		subi r22,-1
 1509 05de 7F4F      		sbci r23,-1
 1510 05e0 87E0      		ldi r24,lo8(7)
 1511 05e2 0E94 0000 		call read_values
 1512               	.LVL150:
 340:roomba.c      **** 		bump_handling(data[0]);
 1513               		.loc 1 340 0 discriminator 1
 1514 05e6 8981      		ldd r24,Y+1
 1515 05e8 0E94 0000 		call bump_handling
 1516               	.LVL151:
 1517 05ec 00C0      		rjmp .L48
 1518               	.LBE10:
 1519               		.cfi_endproc
 1520               	.LFE17:
 1522               	.global	getSensorQueryList
 1524               	getSensorQueryList:
 1525               	.LFB20:
 368:roomba.c      **** }
 369:roomba.c      **** 
 370:roomba.c      **** /**
 371:roomba.c      ****  * \brief get a list of sensor data
 372:roomba.c      ****  * 
 373:roomba.c      ****  * \param nrPackets the number of packets we want to retrieve
 374:roomba.c      ****  * \param packet_ids
 375:roomba.c      ****  * \param packet_length are it 1 or 2 bytes
 376:roomba.c      ****  * \param data a array to return the values
 377:roomba.c      ****  */
 378:roomba.c      **** void getSensorQueryList(uint8_t nrPackets, uint8_t* packet_ids, uint8_t* packet_length, uint16_t* d
 1526               		.loc 1 378 0
 1527               		.cfi_startproc
 1528               	.LVL152:
 1529 05ee 9F92      		push r9
 1530               	.LCFI81:
 1531               		.cfi_def_cfa_offset 4
 1532               		.cfi_offset 9, -3
 1533 05f0 AF92      		push r10
 1534               	.LCFI82:
 1535               		.cfi_def_cfa_offset 5
 1536               		.cfi_offset 10, -4
 1537 05f2 BF92      		push r11
 1538               	.LCFI83:
 1539               		.cfi_def_cfa_offset 6
 1540               		.cfi_offset 11, -5
 1541 05f4 CF92      		push r12
 1542               	.LCFI84:
 1543               		.cfi_def_cfa_offset 7
 1544               		.cfi_offset 12, -6
 1545 05f6 DF92      		push r13
 1546               	.LCFI85:
 1547               		.cfi_def_cfa_offset 8
 1548               		.cfi_offset 13, -7
 1549 05f8 EF92      		push r14
 1550               	.LCFI86:
 1551               		.cfi_def_cfa_offset 9
 1552               		.cfi_offset 14, -8
 1553 05fa FF92      		push r15
 1554               	.LCFI87:
 1555               		.cfi_def_cfa_offset 10
 1556               		.cfi_offset 15, -9
 1557 05fc 0F93      		push r16
 1558               	.LCFI88:
 1559               		.cfi_def_cfa_offset 11
 1560               		.cfi_offset 16, -10
 1561 05fe 1F93      		push r17
 1562               	.LCFI89:
 1563               		.cfi_def_cfa_offset 12
 1564               		.cfi_offset 17, -11
 1565 0600 CF93      		push r28
 1566               	.LCFI90:
 1567               		.cfi_def_cfa_offset 13
 1568               		.cfi_offset 28, -12
 1569 0602 DF93      		push r29
 1570               	.LCFI91:
 1571               		.cfi_def_cfa_offset 14
 1572               		.cfi_offset 29, -13
 1573 0604 1F92      		push __zero_reg__
 1574 0606 1F92      		push __zero_reg__
 1575               	.LCFI92:
 1576               		.cfi_def_cfa_offset 16
 1577 0608 CDB7      		in r28,__SP_L__
 1578 060a DEB7      		in r29,__SP_H__
 1579               	.LCFI93:
 1580               		.cfi_def_cfa_register 28
 1581               	/* prologue: function */
 1582               	/* frame size = 2 */
 1583               	/* stack size = 13 */
 1584               	.L__stack_usage = 13
 1585 060c C82E      		mov r12,r24
 1586 060e E62E      		mov r14,r22
 1587 0610 F72E      		mov r15,r23
 1588 0612 942E      		mov r9,r20
 1589 0614 A52E      		mov r10,r21
 1590 0616 B22E      		mov r11,r18
 1591 0618 D32E      		mov r13,r19
 379:roomba.c      **** 	send_byte_roomba(149);
 1592               		.loc 1 379 0
 1593 061a 85E9      		ldi r24,lo8(-107)
 1594               	.LVL153:
 1595 061c 0E94 0000 		call send_byte_roomba
 1596               	.LVL154:
 380:roomba.c      **** 	send_byte_roomba(nrPackets);
 1597               		.loc 1 380 0
 1598 0620 8C2D      		mov r24,r12
 1599 0622 0E94 0000 		call send_byte_roomba
 1600               	.LVL155:
 1601               	.LBB11:
 381:roomba.c      **** 	
 382:roomba.c      **** 	for (uint8_t a = 0; a < nrPackets; a++) {
 1602               		.loc 1 382 0
 1603 0626 CC20      		tst r12
 1604 0628 01F0      		breq .L49
 1605 062a 0E2D      		mov r16,r14
 1606 062c 1F2D      		mov r17,r15
 1607 062e F12C      		mov r15,__zero_reg__
 1608               	.LVL156:
 1609               	.L52:
 383:roomba.c      **** 		send_byte_roomba(packet_ids[a]);
 1610               		.loc 1 383 0 discriminator 2
 1611 0630 F801      		movw r30,r16
 1612 0632 8191      		ld r24,Z+
 1613 0634 8F01      		movw r16,r30
 1614 0636 0E94 0000 		call send_byte_roomba
 1615               	.LVL157:
 382:roomba.c      **** 	for (uint8_t a = 0; a < nrPackets; a++) {
 1616               		.loc 1 382 0 discriminator 2
 1617 063a F394      		inc r15
 1618               	.LVL158:
 1619 063c FC10      		cpse r15,r12
 1620 063e 00C0      		rjmp .L52
 1621               	.LVL159:
 1622 0640 E92C      		mov r14,r9
 1623 0642 FA2C      		mov r15,r10
 1624               	.LVL160:
 1625 0644 0B2D      		mov r16,r11
 1626 0646 1D2D      		mov r17,r13
 382:roomba.c      **** 	for (uint8_t a = 0; a < nrPackets; a++) {
 1627               		.loc 1 382 0 is_stmt 0
 1628 0648 D12C      		mov r13,__zero_reg__
 1629               	.LVL161:
 1630               	.L55:
 1631               	.LBE11:
 1632               	.LBB12:
 384:roomba.c      **** 	}
 385:roomba.c      **** 	
 386:roomba.c      **** 	for (uint8_t b = 0; b < nrPackets; b++) {
 387:roomba.c      **** 		if (packet_length[b] == 1) {
 1633               		.loc 1 387 0 is_stmt 1
 1634 064a F701      		movw r30,r14
 1635 064c 8191      		ld r24,Z+
 1636 064e 7F01      		movw r14,r30
 1637 0650 8130      		cpi r24,lo8(1)
 1638 0652 01F4      		brne .L53
 388:roomba.c      **** 			data[b] = receive_byte_roomba();
 1639               		.loc 1 388 0
 1640 0654 0E94 0000 		call receive_byte_roomba
 1641               	.LVL162:
 1642 0658 282F      		mov r18,r24
 1643 065a 30E0      		ldi r19,0
 1644 065c F801      		movw r30,r16
 1645 065e 3183      		std Z+1,r19
 1646 0660 2083      		st Z,r18
 1647 0662 00C0      		rjmp .L54
 1648               	.L53:
 1649               	.LBB13:
 389:roomba.c      **** 		} else {
 390:roomba.c      **** 			uint8_t darray[2];
 391:roomba.c      **** 			darray[0] = receive_byte_roomba();
 1650               		.loc 1 391 0
 1651 0664 0E94 0000 		call receive_byte_roomba
 1652               	.LVL163:
 1653 0668 8983      		std Y+1,r24
 392:roomba.c      **** 			darray[1] = receive_byte_roomba();
 1654               		.loc 1 392 0
 1655 066a 0E94 0000 		call receive_byte_roomba
 1656               	.LVL164:
 1657 066e 8A83      		std Y+2,r24
 393:roomba.c      **** 			
 394:roomba.c      **** 			data[b] = concat_bytes(darray);
 1658               		.loc 1 394 0
 1659 0670 CE01      		movw r24,r28
 1660 0672 0196      		adiw r24,1
 1661 0674 0E94 0000 		call concat_bytes
 1662               	.LVL165:
 1663 0678 F801      		movw r30,r16
 1664 067a 9183      		std Z+1,r25
 1665 067c 8083      		st Z,r24
 1666               	.L54:
 1667               	.LBE13:
 386:roomba.c      **** 	for (uint8_t b = 0; b < nrPackets; b++) {
 1668               		.loc 1 386 0
 1669 067e D394      		inc r13
 1670               	.LVL166:
 1671 0680 0E5F      		subi r16,-2
 1672 0682 1F4F      		sbci r17,-1
 1673 0684 DC10      		cpse r13,r12
 1674 0686 00C0      		rjmp .L55
 1675               	.LVL167:
 1676               	.L49:
 1677               	/* epilogue start */
 1678               	.LBE12:
 395:roomba.c      **** 		}
 396:roomba.c      **** 	}
 397:roomba.c      **** }
 1679               		.loc 1 397 0
 1680 0688 0F90      		pop __tmp_reg__
 1681 068a 0F90      		pop __tmp_reg__
 1682 068c DF91      		pop r29
 1683 068e CF91      		pop r28
 1684 0690 1F91      		pop r17
 1685 0692 0F91      		pop r16
 1686 0694 FF90      		pop r15
 1687 0696 EF90      		pop r14
 1688 0698 DF90      		pop r13
 1689 069a CF90      		pop r12
 1690               	.LVL168:
 1691 069c BF90      		pop r11
 1692 069e AF90      		pop r10
 1693 06a0 9F90      		pop r9
 1694 06a2 0895      		ret
 1695               		.cfi_endproc
 1696               	.LFE20:
 1698               	.global	__floatsisf
 1699               	.global	__addsf3
 1700               	.global	__divsf3
 1701               	.global	__fixsfsi
 1702               	.global	drive_with_p_regler
 1704               	drive_with_p_regler:
 1705               	.LFB21:
 398:roomba.c      **** 
 399:roomba.c      **** /**
 400:roomba.c      ****  * \brief Drive along aline with a p regler
 401:roomba.c      ****  */
 402:roomba.c      **** void drive_with_p_regler() {
 1706               		.loc 1 402 0
 1707               		.cfi_startproc
 1708 06a4 CF93      		push r28
 1709               	.LCFI94:
 1710               		.cfi_def_cfa_offset 4
 1711               		.cfi_offset 28, -3
 1712 06a6 DF93      		push r29
 1713               	.LCFI95:
 1714               		.cfi_def_cfa_offset 5
 1715               		.cfi_offset 29, -4
 1716 06a8 CDB7      		in r28,__SP_L__
 1717 06aa DEB7      		in r29,__SP_H__
 1718               	.LCFI96:
 1719               		.cfi_def_cfa_register 28
 1720 06ac 6097      		sbiw r28,16
 1721               	.LCFI97:
 1722               		.cfi_def_cfa_offset 21
 1723 06ae 0FB6      		in __tmp_reg__,__SREG__
 1724 06b0 F894      		cli
 1725 06b2 DEBF      		out __SP_H__,r29
 1726 06b4 0FBE      		out __SREG__,__tmp_reg__
 1727 06b6 CDBF      		out __SP_L__,r28
 1728               	/* prologue: function */
 1729               	/* frame size = 16 */
 1730               	/* stack size = 18 */
 1731               	.L__stack_usage = 18
 1732               	.LVL169:
 403:roomba.c      **** 	uint8_t speed = 250;
 404:roomba.c      **** 	uint8_t abtastzeit = 30;
 405:roomba.c      **** 	
 406:roomba.c      **** 	uint16_t v_right = speed;
 407:roomba.c      **** 	uint16_t v_left = speed;
 408:roomba.c      **** 	
 409:roomba.c      **** 	float kp = 0.1f;
 410:roomba.c      **** 	float kd = 0.08f;
 411:roomba.c      **** 	float ki = 0.00005f;
 412:roomba.c      **** 	
 413:roomba.c      **** 	// Cliff left, right / bumper 
 414:roomba.c      **** 	uint8_t packet_ids[3] = {29, 30, 7};
 1733               		.loc 1 414 0
 1734 06b8 8DE1      		ldi r24,lo8(29)
 1735 06ba 8983      		std Y+1,r24
 1736 06bc 8EE1      		ldi r24,lo8(30)
 1737 06be 8A83      		std Y+2,r24
 1738 06c0 87E0      		ldi r24,lo8(7)
 1739 06c2 8B83      		std Y+3,r24
 415:roomba.c      **** 	uint8_t packet_length[3] = {2, 2, 1};
 1740               		.loc 1 415 0
 1741 06c4 82E0      		ldi r24,lo8(2)
 1742 06c6 8C83      		std Y+4,r24
 1743 06c8 8D83      		std Y+5,r24
 1744 06ca 81E0      		ldi r24,lo8(1)
 1745 06cc 8E83      		std Y+6,r24
 1746               	.LVL170:
 416:roomba.c      **** 	uint16_t qdata[3];
 417:roomba.c      **** 	int32_t esum = 0;
 418:roomba.c      **** 	int16_t ealt = 0;
 1747               		.loc 1 418 0
 1748 06ce A12C      		mov r10,__zero_reg__
 1749 06d0 B12C      		mov r11,__zero_reg__
 417:roomba.c      **** 	int32_t esum = 0;
 1750               		.loc 1 417 0
 1751 06d2 412C      		mov r4,__zero_reg__
 1752 06d4 512C      		mov r5,__zero_reg__
 1753 06d6 3201      		movw r6,r4
 407:roomba.c      **** 	uint16_t v_left = speed;
 1754               		.loc 1 407 0
 1755 06d8 0F2E      		mov __tmp_reg__,r31
 1756 06da FAEF      		ldi r31,lo8(-6)
 1757 06dc CF2E      		mov r12,r31
 1758 06de D12C      		mov r13,__zero_reg__
 1759 06e0 F02D      		mov r31,__tmp_reg__
 406:roomba.c      **** 	uint16_t v_right = speed;
 1760               		.loc 1 406 0
 1761 06e2 0F2E      		mov __tmp_reg__,r31
 1762 06e4 FAEF      		ldi r31,lo8(-6)
 1763 06e6 EF2E      		mov r14,r31
 1764 06e8 F12C      		mov r15,__zero_reg__
 1765 06ea F02D      		mov r31,__tmp_reg__
 1766               	.LBB14:
 419:roomba.c      **** 		
 420:roomba.c      **** 	while (1) {
 421:roomba.c      **** 		drive_direction(v_right, v_left);
 422:roomba.c      **** 		
 423:roomba.c      **** 		// Set speed to straight normal speed
 424:roomba.c      **** 		v_right = speed;
 425:roomba.c      **** 		v_left = speed;
 426:roomba.c      **** 		
 427:roomba.c      **** 		getSensorQueryList(3, packet_ids, packet_length, qdata);
 428:roomba.c      **** 		
 429:roomba.c      **** 		int16_t cliff_left = qdata[0];
 430:roomba.c      **** 		int16_t cliff_right = qdata[1];
 431:roomba.c      **** 		
 432:roomba.c      **** 		int16_t e = cliff_left - cliff_right;
 433:roomba.c      **** 		esum += e;
 434:roomba.c      **** 		int32_t y = kp * e + ki * abtastzeit * esum + kd * (e - ealt) / abtastzeit;
 435:roomba.c      **** 		ealt = e;
 436:roomba.c      **** 		
 437:roomba.c      **** 		// Output on display
 438:roomba.c      **** 		char result[4];
 439:roomba.c      **** 		intToHex(abs(y), result);
 440:roomba.c      **** 		set_Display(result);
 441:roomba.c      **** 		
 442:roomba.c      **** 		// Compensate direction
 443:roomba.c      **** 		v_right += y;
 444:roomba.c      **** 		v_left -= y;
 1767               		.loc 1 444 0
 1768 06ec 0F2E      		mov __tmp_reg__,r31
 1769 06ee FAEF      		ldi r31,lo8(-6)
 1770 06f0 8F2E      		mov r8,r31
 1771 06f2 912C      		mov r9,__zero_reg__
 1772 06f4 F02D      		mov r31,__tmp_reg__
 1773               	.LVL171:
 1774               	.L58:
 421:roomba.c      **** 		drive_direction(v_right, v_left);
 1775               		.loc 1 421 0 discriminator 1
 1776 06f6 B601      		movw r22,r12
 1777 06f8 C701      		movw r24,r14
 1778 06fa 0E94 0000 		call drive_direction
 1779               	.LVL172:
 427:roomba.c      **** 		getSensorQueryList(3, packet_ids, packet_length, qdata);
 1780               		.loc 1 427 0 discriminator 1
 1781 06fe 9E01      		movw r18,r28
 1782 0700 295F      		subi r18,-7
 1783 0702 3F4F      		sbci r19,-1
 1784 0704 AE01      		movw r20,r28
 1785 0706 4C5F      		subi r20,-4
 1786 0708 5F4F      		sbci r21,-1
 1787 070a BE01      		movw r22,r28
 1788 070c 6F5F      		subi r22,-1
 1789 070e 7F4F      		sbci r23,-1
 1790 0710 83E0      		ldi r24,lo8(3)
 1791 0712 0E94 0000 		call getSensorQueryList
 1792               	.LVL173:
 432:roomba.c      **** 		int16_t e = cliff_left - cliff_right;
 1793               		.loc 1 432 0 discriminator 1
 1794 0716 0F81      		ldd r16,Y+7
 1795 0718 1885      		ldd r17,Y+8
 1796 071a 8985      		ldd r24,Y+9
 1797 071c 9A85      		ldd r25,Y+10
 1798 071e 081B      		sub r16,r24
 1799 0720 190B      		sbc r17,r25
 1800               	.LVL174:
 433:roomba.c      **** 		esum += e;
 1801               		.loc 1 433 0 discriminator 1
 1802 0722 B801      		movw r22,r16
 1803 0724 8827      		clr r24
 1804 0726 77FD      		sbrc r23,7
 1805 0728 8095      		com r24
 1806 072a 982F      		mov r25,r24
 1807 072c 460E      		add r4,r22
 1808 072e 571E      		adc r5,r23
 1809 0730 681E      		adc r6,r24
 1810 0732 791E      		adc r7,r25
 1811               	.LVL175:
 434:roomba.c      **** 		int32_t y = kp * e + ki * abtastzeit * esum + kd * (e - ealt) / abtastzeit;
 1812               		.loc 1 434 0 discriminator 1
 1813 0734 0E94 0000 		call __floatsisf
 1814               	.LVL176:
 1815 0738 2DEC      		ldi r18,lo8(-51)
 1816 073a 3CEC      		ldi r19,lo8(-52)
 1817 073c 4CEC      		ldi r20,lo8(-52)
 1818 073e 5DE3      		ldi r21,lo8(61)
 1819 0740 0E94 0000 		call __mulsf3
 1820               	.LVL177:
 1821 0744 6B01      		movw r12,r22
 1822 0746 7C01      		movw r14,r24
 1823 0748 C301      		movw r24,r6
 1824 074a B201      		movw r22,r4
 1825 074c 0E94 0000 		call __floatsisf
 1826               	.LVL178:
 1827 0750 26EA      		ldi r18,lo8(-90)
 1828 0752 3BE9      		ldi r19,lo8(-101)
 1829 0754 44EC      		ldi r20,lo8(-60)
 1830 0756 5AE3      		ldi r21,lo8(58)
 1831 0758 0E94 0000 		call __mulsf3
 1832               	.LVL179:
 1833 075c 9B01      		movw r18,r22
 1834 075e AC01      		movw r20,r24
 1835 0760 C701      		movw r24,r14
 1836 0762 B601      		movw r22,r12
 1837 0764 0E94 0000 		call __addsf3
 1838               	.LVL180:
 1839 0768 6B01      		movw r12,r22
 1840 076a 7C01      		movw r14,r24
 1841 076c B801      		movw r22,r16
 1842 076e 6A19      		sub r22,r10
 1843 0770 7B09      		sbc r23,r11
 1844 0772 8827      		clr r24
 1845 0774 77FD      		sbrc r23,7
 1846 0776 8095      		com r24
 1847 0778 982F      		mov r25,r24
 1848 077a 0E94 0000 		call __floatsisf
 1849               	.LVL181:
 1850 077e 2AE0      		ldi r18,lo8(10)
 1851 0780 37ED      		ldi r19,lo8(-41)
 1852 0782 43EA      		ldi r20,lo8(-93)
 1853 0784 5DE3      		ldi r21,lo8(61)
 1854 0786 0E94 0000 		call __mulsf3
 1855               	.LVL182:
 1856 078a 20E0      		ldi r18,0
 1857 078c 30E0      		ldi r19,0
 1858 078e 40EF      		ldi r20,lo8(-16)
 1859 0790 51E4      		ldi r21,lo8(65)
 1860 0792 0E94 0000 		call __divsf3
 1861               	.LVL183:
 1862 0796 9B01      		movw r18,r22
 1863 0798 AC01      		movw r20,r24
 1864 079a C701      		movw r24,r14
 1865 079c B601      		movw r22,r12
 1866 079e 0E94 0000 		call __addsf3
 1867               	.LVL184:
 1868 07a2 0E94 0000 		call __fixsfsi
 1869               	.LVL185:
 1870 07a6 5B01      		movw r10,r22
 1871 07a8 6C01      		movw r12,r24
 1872               	.LVL186:
 439:roomba.c      **** 		intToHex(abs(y), result);
 1873               		.loc 1 439 0 discriminator 1
 1874 07aa CB01      		movw r24,r22
 1875 07ac 9923      		tst r25
 1876 07ae 04F4      		brge .L57
 1877 07b0 8827      		clr r24
 1878 07b2 9927      		clr r25
 1879 07b4 8A19      		sub r24,r10
 1880 07b6 9B09      		sbc r25,r11
 1881               	.L57:
 1882 07b8 BE01      		movw r22,r28
 1883 07ba 635F      		subi r22,-13
 1884 07bc 7F4F      		sbci r23,-1
 1885 07be 0E94 0000 		call intToHex
 1886               	.LVL187:
 440:roomba.c      **** 		set_Display(result);
 1887               		.loc 1 440 0 discriminator 1
 1888 07c2 CE01      		movw r24,r28
 1889 07c4 0D96      		adiw r24,13
 1890 07c6 0E94 0000 		call set_Display
 1891               	.LVL188:
 443:roomba.c      **** 		v_right += y;
 1892               		.loc 1 443 0 discriminator 1
 1893 07ca 7501      		movw r14,r10
 1894 07cc 8AEF      		ldi r24,-6
 1895 07ce E80E      		add r14,r24
 1896 07d0 F11C      		adc r15,__zero_reg__
 1897               	.LVL189:
 1898               		.loc 1 444 0 discriminator 1
 1899 07d2 6401      		movw r12,r8
 1900 07d4 CA18      		sub r12,r10
 1901 07d6 DB08      		sbc r13,r11
 1902               	.LVL190:
 445:roomba.c      **** 		
 446:roomba.c      **** 		bump_handling(qdata[2]);
 1903               		.loc 1 446 0 discriminator 1
 1904 07d8 8B85      		ldd r24,Y+11
 1905 07da 0E94 0000 		call bump_handling
 1906               	.LVL191:
 447:roomba.c      **** 		
 448:roomba.c      **** 		my_msleep(abtastzeit);
 1907               		.loc 1 448 0 discriminator 1
 1908 07de 8EE1      		ldi r24,lo8(30)
 1909 07e0 90E0      		ldi r25,0
 1910 07e2 0E94 0000 		call my_msleep
 1911               	.LVL192:
 435:roomba.c      **** 		ealt = e;
 1912               		.loc 1 435 0 discriminator 1
 1913 07e6 5801      		movw r10,r16
 1914 07e8 00C0      		rjmp .L58
 1915               	.LBE14:
 1916               		.cfi_endproc
 1917               	.LFE21:
 1919               	.Letext0:
 1920               		.file 2 "/usr/lib/avr/include/stdint.h"
 1921               		.file 3 "usart.h"
 1922               		.file 4 "tools.h"
 1923               		.file 5 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 roomba.c
     /tmp/cc82RhfR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc82RhfR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc82RhfR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc82RhfR.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc82RhfR.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc82RhfR.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc82RhfR.s:13     .text:0000000000000000 initializeRoomba
     /tmp/cc82RhfR.s:36     .text:000000000000000e set_Display
     /tmp/cc82RhfR.s:97     .text:000000000000003c read_button
     /tmp/cc82RhfR.s:141    .text:000000000000005e read_values
     /tmp/cc82RhfR.s:219    .text:000000000000009e drive
     /tmp/cc82RhfR.s:271    .text:00000000000000ca stop
     /tmp/cc82RhfR.s:290    .text:00000000000000d4 getTicks
     /tmp/cc82RhfR.s:347    .text:0000000000000100 drive_roomba
     /tmp/cc82RhfR.s:543    .text:00000000000001f4 drive_roomba_exact
     /tmp/cc82RhfR.s:783    .text:0000000000000314 receiveRemote
     /tmp/cc82RhfR.s:832    .text:000000000000033a intToHex
     /tmp/cc82RhfR.s:879    .text:000000000000035c showRemoteSignalInDisplay
     /tmp/cc82RhfR.s:956    .text:00000000000003ac driveWithRadius
     /tmp/cc82RhfR.s:1029   .text:00000000000003e4 read_user_input
     /tmp/cc82RhfR.s:1302   .text:0000000000000524 drive_circle
     /tmp/cc82RhfR.s:1325   .text:0000000000000530 turn
     /tmp/cc82RhfR.s:1404   .text:0000000000000586 set_back
     /tmp/cc82RhfR.s:1433   .text:00000000000005a0 bump_handling
     /tmp/cc82RhfR.s:1474   .text:00000000000005c4 drive_autonom
     /tmp/cc82RhfR.s:1524   .text:00000000000005ee getSensorQueryList
     /tmp/cc82RhfR.s:1704   .text:00000000000006a4 drive_with_p_regler

UNDEFINED SYMBOLS
send_byte_roomba
receive_byte_roomba
concat_bytes
sprintf
sendString
__udivmodhi4
my_msleep
__floatunsisf
__mulsf3
__fixunssfsi
__floatsisf
__addsf3
__divsf3
__fixsfsi
drive_direction
__do_copy_data
